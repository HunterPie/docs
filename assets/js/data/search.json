[ { "title": "Theme System", "url": "/posts/theme/", "categories": "Documentation, Customization", "tags": "", "date": "2026-02-17 22:49:00 +0800", "snippet": "HunterPie’s theme system provides powerful customization capabilities, allowing users to completely override the application’s appearance and create personalized designs. You can customize everything from basic colors to complete widget redesigns.OverviewThe theme system operates through XAML resource overrides, that means you can: Override default colors and styles: Change the core visual elements of HunterPie Fully customize widget designs: Create entirely new layouts and appearances for overlay widgetsDefault ResourcesHunterPie’s default theme consists of two main resource files: Colors (Scheme.xaml): Contains all color definitions and brushes Widget Styles (Base.xaml): Contains widget styles, overlay colors, and templatesHow to Create a ThemeA HunterPie theme consists of two essential components: Theme Manifest (theme.manifest.json) - Contains metadata about your theme XAML Files (.xaml) - Contains the actual styling and resource overridesTheme Manifest StructureThe theme.manifest.json file stores your theme’s metadata and is required for HunterPie to recognize your theme:{ &quot;id&quot;: &quot;&amp;lt;THIS MUST BE UNIQUE&amp;gt;&quot;, &quot;name&quot;: &quot;My cool theme&quot;, &quot;description&quot;: &quot;A very cool theme with very cool designs&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;author&quot;: &quot;Haato&quot;, &quot;tags&quot;: [ &quot;overlay&quot;, &quot;monster-widget&quot; ]}Manifest Properties Property Description id A unique identifier for your theme (MUST BE UNIQUE). Generate a new UUID for each theme here. name The display name of your theme description A brief description of what your theme offers version Your theme’s version number (use semantic versioning) author Your name or username tags Array of descriptive tags (currently not used by HunterPie but recommended to fill) Important: The id property must be unique across all themes. Use a GUID generator to create a unique identifier.XAML File Loading Order XAML files are loaded in alphabetical order If multiple files override the same resource, the last loaded file takes priority Use filenames to control loading order (e.g., 01-colors.xaml, 02-widgets.xaml)Basic Theme Structure&amp;lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&amp;gt; &amp;lt;!-- Your custom resources go here --&amp;gt; &amp;lt;/ResourceDictionary&amp;gt;Importing namespacesSometimes you might need to import namespaces into your ResourceDictionary so you can use HunterPie’s built-in converters and markups. Let’s say you need to import the converter that multiplies two numbers MultiplyNumberConverter.To do that, you will need to add the following line to your ResourceDictionary header:&amp;lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:arithmetics=&quot;clr-namespace:HunterPie.UI.Architecture.Converters.Arithmetics;assembly=HunterPie.UI&quot;&amp;gt; &amp;lt;!-- ^ This is what should be added to your ResourceDictionary --&amp;gt;&amp;lt;!-- Once you added the namespace to your file, you can now use the resources from that namespace --&amp;gt;&amp;lt;arithmetics:MultiplyNumberConverter x:Key=&quot;MultiplyByTwo&quot; Factor=&quot;2&quot; /&amp;gt;For a list of all converters, take a look at HunterPie’s source code: ConvertersOverriding ColorsTo override colors, create a resource with the exact same name as the default resource. Here are some commonly customized colors:Core UI Colors&amp;lt;!-- Background colors --&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.HunterPie.Background.Primary&quot;&amp;gt;#1a1a1a&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.HunterPie.Background.Secondary&quot;&amp;gt;#2a2a2a&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.HunterPie.Background.Tertiary&quot;&amp;gt;#3a3a3a&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;!-- Text colors --&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.HunterPie.Foreground.Primary&quot;&amp;gt;#ffffff&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.HunterPie.Foreground.Secondary&quot;&amp;gt;#cccccc&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;!-- Accent colors --&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.HunterPie.Accent.Solid&quot;&amp;gt;#ff6b35&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;Brushes.HunterPie.Accent&quot; StartPoint=&quot;0,1&quot; EndPoint=&quot;1,1&quot;&amp;gt; &amp;lt;GradientStop Offset=&quot;0.863&quot; Color=&quot;#ff6b35&quot; /&amp;gt; &amp;lt;GradientStop Offset=&quot;1&quot; Color=&quot;#f7931e&quot; /&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;Gray Scale Palette&amp;lt;!-- Customize the gray scale used throughout the app --&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray&quot;&amp;gt;#404040&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@50&quot;&amp;gt;#303030&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@100&quot;&amp;gt;#252525&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@200&quot;&amp;gt;#202020&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@300&quot;&amp;gt;#1a1a1a&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@400&quot;&amp;gt;#151515&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@500&quot;&amp;gt;#101010&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@600&quot;&amp;gt;#0a0a0a&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Gray@700&quot;&amp;gt;#050505&amp;lt;/SolidColorBrush&amp;gt;Widget-Specific ColorsMonster Widget&amp;lt;!-- Monster health bars --&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.Widgets.Monster.Health.Default&quot;&amp;gt;#4a90e2&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;Brushes.Widgets.Monster.Health.Default.Background&quot;&amp;gt;#1a3a5c&amp;lt;/SolidColorBrush&amp;gt;&amp;lt;!-- Enraged state --&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;Brushes.Widgets.Monster.Health.Enraged&quot; EndPoint=&quot;1,1&quot; StartPoint=&quot;0,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#e74c3c&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#c0392b&quot; Offset=&quot;1&quot;/&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;Player HUD Widget&amp;lt;!-- Player health --&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;Brushes.Widgets.Player.Health.Default&quot; EndPoint=&quot;1,1&quot; StartPoint=&quot;0,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#27ae60&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#2ecc71&quot; Offset=&quot;1&quot;/&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;&amp;lt;!-- Player stamina --&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;Brushes.Widgets.Player.Stamina.Default&quot; EndPoint=&quot;1,1&quot; StartPoint=&quot;0,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#f39c12&quot; Offset=&quot;1&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#e67e22&quot; Offset=&quot;0&quot;/&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;Weapon-Specific Colors&amp;lt;!-- Longsword spirit gauge levels --&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;Brushes.Widgets.Longsword.LevelOne&quot; EndPoint=&quot;1,1&quot; StartPoint=&quot;0,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#ecf0f1&quot; Offset=&quot;1&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#bdc3c7&quot; Offset=&quot;0&quot;/&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;Brushes.Widgets.Longsword.LevelTwo&quot; EndPoint=&quot;1,1&quot; StartPoint=&quot;0,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#f1c40f&quot; Offset=&quot;1&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#f39c12&quot; Offset=&quot;0&quot;/&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;Brushes.Widgets.Longsword.LevelMax&quot; EndPoint=&quot;1,1&quot; StartPoint=&quot;0,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#e74c3c&quot; Offset=&quot;1&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#c0392b&quot; Offset=&quot;0&quot;/&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;Custom Widget StylesTo fully customize a widget’s appearance, override its style and set a custom Template:&amp;lt;Style x:Key=&quot;Widgets.Monster&quot; TargetType=&quot;{x:Type UserControl}&quot;&amp;gt; &amp;lt;Setter Property=&quot;Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;{x:Type UserControl}&quot;&amp;gt; &amp;lt;!-- Your custom widget layout --&amp;gt; &amp;lt;Border Background=&quot;{StaticResource Brushes.HunterPie.Background.Primary}&quot; BorderBrush=&quot;{StaticResource Brushes.HunterPie.Border}&quot; BorderThickness=&quot;2&quot; CornerRadius=&quot;5&quot;&amp;gt; &amp;lt;!-- Bind to the Monsters collection --&amp;gt; &amp;lt;ItemsControl ItemsSource=&quot;{Binding Monsters, Mode=OneWay}&quot;&amp;gt; &amp;lt;ItemsControl.ItemsPanel&amp;gt; &amp;lt;ItemsPanelTemplate&amp;gt; &amp;lt;StackPanel Orientation=&quot;Vertical&quot; /&amp;gt; &amp;lt;/ItemsPanelTemplate&amp;gt; &amp;lt;/ItemsControl.ItemsPanel&amp;gt; &amp;lt;!-- Template for each monster --&amp;gt; &amp;lt;ItemsControl.ItemTemplate&amp;gt; &amp;lt;DataTemplate&amp;gt; &amp;lt;TextBlock Text=&quot;{Binding Name, Mode=OneWay}&quot; Foreground=&quot;{StaticResource Brushes.HunterPie.Foreground.Primary}&quot; FontSize=&quot;14&quot; Margin=&quot;10,5&quot; HorizontalAlignment=&quot;Left&quot;/&amp;gt; &amp;lt;/DataTemplate&amp;gt; &amp;lt;/ItemsControl.ItemTemplate&amp;gt; &amp;lt;/ItemsControl&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt;&amp;lt;/Style&amp;gt;Understanding Widget Data BindingEach widget in HunterPie has its own view model that exposes different properties and data collections. When creating custom widget themes, it’s your responsibility to: Bind to the correct properties - Each widget’s view model has specific properties you need to bind to for data display Respect configuration settings - Bind to configuration properties when possible so user settings apply to your custom theme Use proper binding modes - Most data should use Mode=OneWay for performance reasonsCommon Widget PropertiesMost widgets follow similar patterns for their view models: Data Collections - ObservableCollection&amp;lt;T&amp;gt; properties (e.g., Monsters, Players, Ailments) Configuration - Config property containing user settings for that specific Widget Display Values - Formatted strings and numeric values for UI displayBinding to ConfigurationAlways check if the widget exposes configuration properties and bind to them when appropriate:&amp;lt;!-- Example: Bind to user&#39;s width settings --&amp;gt;&amp;lt;Border Width=&quot;{Binding Config.Width.Current, Mode=OneWay}&quot;&amp;gt; &amp;lt;!-- Your content --&amp;gt;&amp;lt;/Border&amp;gt;&amp;lt;!-- Example: Respect visibility settings --&amp;gt;&amp;lt;StackPanel Visibility=&quot;{Binding Config.IsVisible.Value, Converter={StaticResource BooleanToVisibilityConverter}}&quot;&amp;gt; &amp;lt;!-- Your content --&amp;gt;&amp;lt;/StackPanel&amp;gt;This ensures your custom theme respects the user’s preferences and behaves consistently with the default theme. To find out what properties are available for each widget and their respective View Model, refer to the source code.Available Widget StylesYou can customize the following widget styles: Widgets.SpecializedToolV2 - Specialized Tools widget Widgets.Monster - Monster information widget Widgets.DamageMeter - Damage meter widget Widgets.DamageMeterV2 - Updated damage meter widget Widgets.AbnormalityTray - Buff/debuff display widget Widgets.Activities - Activities widget Widgets.Chat - Chat widget Widgets.Wirebug - Wirebug widgetTesting Your ThemeHunterPie supports hot-reloading for themes, which means you can see your changes instantly without restarting the application.Method 1: Using Mocked Widgets (Recommended)The easiest way to test your theme is by enabling mocked widgets in HunterPie’s development settings: Enable Development Mode - Read Development Tools to learn to enable development tools Enable Mocked Widgets - Turn on the “Mock Widgets” option in the development settings Apply Your Theme - Select your custom theme from the theme settings View Results - All widgets will display with sample dataMethod 2: Testing with Real Game DataFor more realistic testing, you can test your theme while actually playing: Launch Monster Hunter - Start the game and join a hunt Apply Your Theme - Ensure your custom theme is selected in HunterPie Test Widget Behavior - Interact with the game to see how your widgets respond to real data Modify and Reload - Make changes to your XAML files and they’ll update automaticallyHot-ReloadSaving any file within your loaded theme folder will cause HunterPie to re-load that theme and apply the new styles immediately. In case of any errors, check your HunterPie’s console for more information.Advanced CustomizationUsing Markup ExtensionsHunterPie provides custom markup extensions to make your life easier:&amp;lt;SolidColorBrush x:Key=&quot;CustomBrush&quot; Color=&quot;{markup:BrushColor Brush={StaticResource Gray}, Opacity=0.5}&quot;/&amp;gt;Gradient BrushesCreate sophisticated visual effects with gradient brushes:&amp;lt;!-- Linear gradient --&amp;gt;&amp;lt;LinearGradientBrush x:Key=&quot;CustomGradient&quot; StartPoint=&quot;0,1&quot; EndPoint=&quot;1,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#3498db&quot; Offset=&quot;0&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#2980b9&quot; Offset=&quot;1&quot;/&amp;gt;&amp;lt;/LinearGradientBrush&amp;gt;&amp;lt;!-- Radial gradient --&amp;gt;&amp;lt;RadialGradientBrush x:Key=&quot;CustomRadial&quot; RadiusX=&quot;1&quot; RadiusY=&quot;1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#e74c3c&quot; Offset=&quot;0&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#c0392b&quot; Offset=&quot;1&quot;/&amp;gt;&amp;lt;/RadialGradientBrush&amp;gt;Color VariationsCreate color variations using opacity and system resources:&amp;lt;!-- Semi-transparent variant --&amp;gt;&amp;lt;SolidColorBrush x:Key=&quot;CustomColor.Transparent&quot; Color=&quot;#80e74c3c&quot;/&amp;gt;&amp;lt;!-- Using system types --&amp;gt;&amp;lt;system:Double x:Key=&quot;CustomOpacity&quot;&amp;gt;0.8&amp;lt;/system:Double&amp;gt;" }, { "title": "Development Tools", "url": "/posts/development-tools/", "categories": "Documentation, Customization", "tags": "", "date": "2026-02-17 22:49:00 +0800", "snippet": "HunterPie includes development tools that help with development, debugging, and testing. These tools are hidden by default but can be enabled through feature flags.Enabling Development ToolsTo access HunterPie’s development features, you’ll need to enable them through the feature flags system:Step 1: Enable Development Feature Flags Open HunterPie Settings Click on “Client” settings Scroll all the way down to the bottom of the settings page Enable “Enable development feature flags”Step 2: Reload Settings Exit the settings page completely Re-enter the settings page to reload all options This step is crucial as it refreshes the settings interface to show newly available options.Step 3: Access Feature Flags In the settings page, scroll down on the sidebar At the very bottom, you’ll now see a “Feature Flags” option Click on “Feature Flags”Step 4: Enable Advanced Development Features In the Feature Flags section, find “feature_enable_advanced_dev” Enable this feature flagStep 5: Restart HunterPie Restart HunterPie by pressing Ctrl+RAfter following these steps, you’ll have access to HunterPie’s full development options, including: Mock Widgets - Test themes with fake data without running the game Overlay Manager - Controls design mode, position and settings of the mocked widgetsDevelopment FeaturesOnce development tools are enabled, you can access various debugging and testing features that make theme development and troubleshooting much easier. Important: Some development features may impact performance and are intended for development use only. Disable them for normal gameplay." }, { "title": "HunterPie v2.14.0", "url": "/posts/update-v2.14.0/", "categories": "Update, v2", "tags": "", "date": "2026-02-17 00:22:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!Monster WidgetThe Monster Widget has received a complete visual overhaul to provide a cleaner, more intuitive interface for tracking monster information. This redesign focuses on improved readability and better organization of monster parts, ailments, and health data.Enhanced Monster Target InferenceThe monster targeting system has been significantly improved with better inference algorithms. HunterPie now provides more accurate automatic target detection based on monster proximity, health and combat engagement.New customizationsIt is now possible to: Toggle visual elements individually Change whether you want horizontal or vertical parts and ailmentsAbnormalities Widget Added the ability to choose between compact or detailed mode. Detailed mode will display the abnormality name. It is now possible to configure the number of rows or columns that will be used to display abnormalities.Damage Meter Widget Monster Hunter Rise now uses the new damage meter Added raw damage, elemental damage and affinity valuesGame Support UpdatesMonster Hunter World Enhancements Breakable parts support - Enhanced tracking of breakable monster parts with improved visual indicators Omega monster data - Added IsNotCapturable property for Omega variants to prevent capture indicator displaySystem.NET 10 MigrationHunterPie has been upgraded to .NET 10, bringing performance improvements, enhanced stability, and access to the latest framework features.User ExperienceEnhanced Update System Improved update failure debugging - Better error reporting and diagnostics when updates fail Increased framerate cap - Users can now set higher framerate limits for animationsBug Fixes Fixed monster ailment proc count tracking in Monster Hunter Wilds Fixed supporter hunters not being included in hunt data exports Fixed an issue where the damage meter wouldn’t show anything in expeditions and training room in Monster Hunter World Fixed issue where feature flag settings would not render anything Fixed incorrect data updates for cohoot nest tracking in Monster Hunter Rise Fixed Invalid double value passed to DoubleAnimation.To error that could cause client crashes Fixed LineSeries Visibility being set before adding to chart, preventing rendering issues Fixed null reference exceptions in property chain access that could cause unexpected crashes" }, { "title": "Activities Widget", "url": "/posts/activities-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2025-10-24 06:21:00 +0800", "snippet": "The Activities Widget is responsible for tracking and displaying data from activities from the game.GamesMonster Hunter WildsThe following activities are supported: Material Retrieval; Support Ship; Rations; Monster Hunter Wilds WidgetMonster Hunter WorldThe following activities are supported: Harvest Box; Steamworks; Argosy; Tailraiders; Monster Hunter World WidgetMonster Hunter RiseThe following activities are supported: Submarines; Meowcenaries; Training Dojo; Cohoot Nests; Monster Hunter Rise WidgetSettingsIt is possible to toggle any individual activity of the widget, HunterPie will adjust it’s content automatically." }, { "title": "HunterPie v2.13.0", "url": "/posts/update-v2.13.0/", "categories": "Update, v2", "tags": "", "date": "2025-10-22 00:51:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!Theme System OverhaulStarting with v2.13, HunterPie will have a new theming system. This new system is built with 2 key principles in mind:A better experience to usersThere is now a new UI that allows the user to toggle, manage and order the themes to define a load priority. That means it is now possible to have multiple themes enabled at the same time.A better experience to developersWith the new system, it is now possible to have hot-reloading, allowing theme developers to test and see the results in real-time, without having to restart the whole application. This applies to both the client and also the overlay! There are still some limitations on the hot-reloading support, but it shouldn’t be an issue to 99% of the cases.Color SchemesWith the introdution of the new theme system, there has also been a change on HunterPie’s client color scheme. This change doesn’t affect the overlay in any way, it was mostly to make the client itself more consistent keeping only 3 foreground colors and 3 background colors.Settings Added conditional settings, that means that settings that dependends on other settings to be enabled, will be hidden if their dependencies’ conditions are not met.OverlayActivities Widget Added support to Monster Hunter Wilds activities. Design overhaul of the widget for every supported game.Specialized Tool Widget Added support to Monster Hunter Wilds mantles. Design overhaul of the widget. It is now possible to choose between compact or detailed mode for the widget. compact mode detailed modeClock Widget Added Moon Phases tracking for Monster Hunter Wilds.Damage Meter Widget HunterPie is now able to track supporter hunters damage. Added setting that allows the user to hide every party member other than themselves.Abnormalities Widget Added support to critical draw and power stone buffs. Fixed some missing abnormalities icons and names.Other Changes… HunterPie’s animations are no longer locked at a maximum of 60 FPS. It is now possible to choose a limit, if any at all. It is now possible to completely disable monster targeting.Bug Fixes Fixed issue where clicking on buttons wouldn’t unfocus the last focused UI element. Fixed issue where that would cause abnormality tray settings to only be saved when leaving the configuration window." }, { "title": "HunterPie v2.12.0", "url": "/posts/update-v2.12.0/", "categories": "Update, v2", "tags": "", "date": "2025-04-19 02:13:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!GamesMonster Hunter WildsPartial support to Monster Hunter Wilds has been added, the current features supported are: Monster Widget Abnormalities Widget Clock Widget Damage Meter Widget Exporting of Hunts (requires an account) Discord Rich PresenceClientHome, sweet homeFor the longest time, the console has been HunterPie’s home, v2.12 comes to change that. HunterPie now has a proper home, with actual useful quick access buttons to edit game configurations, launch games and also buttons that can take you to the documentation and the Discord server.In the future, this will also be the home to game specific informations and more. HunterPie’s HomeHunt Export Added option to visualize Moving Average DPS or Overall DPS done throughout the exported quest Added option to visualize the monster’s health over time Fixed issue where toggling a player’s damage, switching tabs, and then coming back to the original tab would make the damage toggle button stop work.OverlayDamage Meter OverhaulThe Damage Meter was completely remade, both the UI and the core were implemented from scratch, the key features for this new version are: New UI, more consistent with current HunterPie’s design and colors New way to plot DPS in the plotting chart, you can read more about it here. This new version of Damage Meter are available for Monster Hunter Wilds &amp;amp; Monster Hunter WorldMonster WidgetCompact ModeThe compact mode only displays the monster’s basic information, that includes: Name Icon CrownHunterPie will automatically switch to the detailed mode once a monster is targeted, this change has been added to every supported game, however it is possible to turn it off in the Monster Widget settings. Compact ModeBug Fixes Fixed HunterPie .zip detection, now it is possible to run HunterPie from a folder within the appdata folder Fixed issue where HunterPie would not truncate the log file" }, { "title": "HunterPie v2.11.0", "url": "/posts/update-v2.11.0/", "categories": "Update, v2", "tags": "", "date": "2024-09-10 11:01:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon! Monster WidgetIt is now possible to configure parts and ailments globally and per monster. Creating a configuration rule for a specific monster will override the global configuration. Clock WidgetThis new widget is responsible for tracking the world time and also the time left on your quest. It is designed to be minimal to avoid cluttering the screen. UI Enhancements Complete redesign of Hunt export summaries: Added quest name, difficulty and type Added death counter Added slay and capture indicators for monsters in quest Summaries are now paginated to avoid loading hundreds of items at once Miscellaneous Added option to hide DPS and total damage in the damage meter widget Upgraded runtime version to .NET 8.0, you can download the runtime here. Removed support for Monster Hunter Rise DEMO Bug Fixes Piercing Bind gauge should no longer be visible in the Dual Blades widget when playing Monster Hunter World Fixed issue where the damage widget timer would reset at the end of a quest, causing the final DPS to be calculated incorrectly Fixed issue where the Insect Glaive widget would stop working due to invalid data being read by HunterPie Fixed timers affected by Power Prolonger running slower instead of increasing the actual timer in Monster Hunter World Fixed racing condition when downloading monster icons for the same monster at the same time Fixed issue where the side bar would not scale properly in high DPI screens Fixed issue where HunterPie would return to last visited page when user logs out, even when the user was not in the account settings page Fixed issue where Steamworks would appear as full at 600 out of 700 fuel Fixed issue where HunterPie would crash due to a racing condition in widgets disposal" }, { "title": "HunterPie v2.10.0", "url": "/posts/update-v2.10.0/", "categories": "Update, v2", "tags": "", "date": "2024-01-09 06:23:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon! Class Widgets Added support for Switch Axe Added support for Longsword Other classes will be supported in the upcoming updates. Switch AxeThe Switch Axe helper tracks and displays all the relevant information you need to play with the Switch Axe. LongswordThe Longsword helper tracks information about your Longsword. Monster Widget Added alternative modes for targeting monsters Lock On: Uses the in-game lock-on to track the target. [MHWorld] Map Pin: Uses the in-game map pin to track the target, quests automatically target the primary quest target automatically. [MHRise] Quest Target: Uses the in-game quest target to track the monster, note that it only works in quests. Inference: HunterPie will try to automatically detect the target based on what happens in-game. UI Enhancements Completely redesigned HunterPie’s client settings to make it easier to navigate. Settings are now grouped by category. Moved account to the top of HunterPie’s client window. Using the design mode to scale widgets should now modify the scale by 5% instead of 1%. Bug Fixes Fixed the sharpness gauge not detecting the maximum sharpness correctly for Monster Hunter World. Removed dummy animation on Widgets to force constant rendering." }, { "title": "HunterPie v2.9.0", "url": "/posts/update-v2.9.0/", "categories": "Update, v2", "tags": "", "date": "2023-07-13 13:17:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon! Class Widgets Added support for Charge Blade Added support for Dual Blades Added support for Insect Glaive Other classes will be supported in the upcoming updates. Charge BladeThe Charge Blade helper tracks and displays all the information you need to play the Charge Blade, including weapon specific buff timers and build-ups. Insect GlaiveThe Insect Glaive helper tracks informations about your Kinsect and weapon buffs, it is designed to be able to replace the in-game HUD element. Dual BladesThe Dual Blades helper tracks informations about your Demon build-up, Piercing Bind and the state of demon mode. UI Enhancements Launch game button now allows the user to change the game to be launched, you no longer have to change it in HunterPie’s settings. Changing it directly from the button will also update your settings automatically. Completely redesigned some components to make everything look more consistent. Completely redesigned the settings window. Abnormality tray settings no longer opens a new window, it will use HunterPie’s client window instead. Completely redesigned HunterPie’s design mode. Bug Fixes HunterPie will no longer show the “Connected to Discord” message if Rich Presence integration is disabled." }, { "title": "HunterPie - An in-depth overview", "url": "/posts/hunterpie-an-in-depth-overview/", "categories": "Blog, Architecture", "tags": "", "date": "2023-06-03 04:18:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!HunterPie is an overlay for Monster Hunter games, it displays useful in-game information that are not visible to the player such as monster health, damage done, time left on your buffs and debuffs and some weapon-specific data.In order for it to work, it needs to get those values from somewhere, in this case, from the game process’s memory itself! The thing is, messing with closed source software isn’t really straightforward, depending on how a process was compiled and which language it was made on, the human readable part code is completely removed from the binaries, you won’t have the class, structs, function and method names, it will be just a bunch of bytes, offsets and instructions.This article will be split up into 2 topics, the reverse engineering and HunterPie’s architecture.The Reverse EngineeringReverse engineering is an arduous and time consuming, although fun, process. A big part of it is to assume things, I’m not a game developer myself but as a software engineer you can have a pretty good idea on how things are implemented.For instance, what is the first thing that comes in mind when you think of a health value? Probably a number, those can be usually implemented using integers or floating point decimals, in the case of Monster Hunter World, that was implemented using a float type.It is important to note that in order to assume things, you also need to understand the basics of data types and data structures. For example, how would the following data structure look like in memory in a x64 game?struct Player { float health; float maxHealth; char* name;};It would look like the following:The other important part of reverse engineering is to understand at least the basics of what happens when a program is compiled down to native machine code, what is the stack memory? The heap? If you wrote a code that access a field in a class, what would that look like in assembly? All that is important to know before diving into how HunterPie works exactly and I’ll be explaining those concepts since they’re really important.Types, Structures &amp;amp; ClassesMonster Hunter World is written in C++ and follows the OOP concepts, which means there are a lot of abstract classes, inheritance, etc.TypesMemory is just a contiguous and really big array bytes, knowing all the primitive types is really helpful because that’s how you’re going to be able to map the structures by hand, for instance, the following little endian hex value 00 00 80 3F is the float32 value for 1.0, but if you tried to read it as an int, it would represent 1065353216. Depending on how you read the bytes or how many bytes you are reading the value can change drastically. When I look at the memory, deducing the type I’m working with is very contextual.There are a couple of things you can look for when trying to figure out which types you’re looking at, for example, when you’re working with a float or double, those are usually stored in floating point registers (xmm0, xmm1, etc) or handled by floating point instructions like the movss. On the other hand, integers are usually stored in the QWORD registers (rax, rbx, etc).StructuresYou can think of a structure as a little box of primitive types, when you’re looking at memory you won’t be able to tell how many fields there are, or where a field starts or ends, that’s when putting breakpoints on the memory addresses with a debugger come useful. It allows you to see which instructions access that given memory address, here’s a simple example:movss xmm0, [eax]mov rbx, [rax+4]movss xmm1, [ebx]When looking at the previous two instructions, we can tell that rax is an structure and it has two fields, the first field is mostly likely afloat since it’s being put in a float register, the second one is a pointer since it’s being dereferenced with the offset 4, the pointer also points to another structure with a float. You could represent that as:struct RBX { float value;};struct RAX { float value; RBX* rbx;};ClassesAn easy way to think of classes in memory is to think of a struct, and the methods as functions where the first parameter is a reference to that struct. Consider the following class:class Player { public: float GetHealth() { return this-&amp;gt;m_health; } char* GetName() { return this-&amp;gt;m_name; } private: float m_health; float m_maxHealth; char* m_name;}It’s safe to say that if you compiled the previous class and wanted to “transpile” the assembly code to something more human readable, it would look something like this:struct Player { float health; float maxHealth; char* name;};float GetHealth(Player* player) { return player-&amp;gt;health;}char* GetName(Player* player) { return player-&amp;gt;name;}It’s good to know these type of things because when you’re reverse engineering a procedure in assembly, if the first parameter is an 8 byte long value that is often dereferenced with offsets, there’s a pretty big chance that procedure is an implementation of a method for that given pointer, and that helps a lot when trying to understand what that procedure does.In the case of virtual functions, things change a little bit and get more complicated, a table will be created for that class and a pointer to that table will be the first field in the structure, this was very common in Monster Hunter World, as every monster had it’s own class but they all inherited a common enemy class with virtual methods. The same class Player could be represented like this if it implemented virtual functions:struct Player { void* vptr; float health; float maxHealth; char* name;}Although the vtable is generated automatically by the compiler, the dereference and calls are done in runtime, so unlike non-virtual functions that are called by their already-known relative address, virtual functions need to be dereferenced and put into a register before being called, which makes it fairly easy to tell when you’re dealing with a virtual function.; Assuming rax is a Player*mov rbx, [rax] ; Puts the value of vptr into the rbx registermov rdx, [rbx] ; Puts the pointer to the virtual function into the rdx registercall rdx ; Calls the virtual functionMemoryThe process’s memory can be split up in two, the static memory and the dynamic memory. The static memory is the one that is embedded in the executable itself, the compiler is the one responsible for this one, this memory is where global and static variables are, this is very important because that’s how HunterPie (and the software itself) get to the values in the dynamic memory. The memory addresses in the static memory are always the same, unless you change something internally in the code and recompile your program.The dynamic memory on the other hand is well… Dynamic! The addresses are never the same, those are handled by the OS in runtime whenever your software needs more memory. The heap and the stack are also part of the dynamic memory, whenever you use the keyword new or use the malloc function, it will reserve some space in the memory and give you a pointer to that address, and for local variables the stack will be used for primitive types.The thing is, you can get to anything in the dynamic memory from the static memory, you just need the right offsets to get to your desired data, and that’s the tricky part. The process of finding the offsets from the static memory to the value you want is done backwards; First you find the value you want by scanning the dynamic memory with possible values (this is where assuming things come in) and then you put a breakpoint on the accessors of that value and look at what which instructions accesses them.Consider the following image:Let’s say the value you found is the second field in the Structure 3, the int one, when you put a breakpoint on it, you might get an instruction accessing a register plus the offset 4, something like this:mov ebx, [eax+4] ; The instruction and registers might differThat means the base address of our structure is 0x1004 - 4 = 0x1000, with that value you can now scan for all addresses that contains the value 0x1000, that will give you a list of all possible Structure 3 pointers.You can now put a breakpoint on that pointer and see the instructions, that access it, it should be something like:mov rbx, [rax+14h]By doing the same process you did previously, you’ll find the static memory, now you can always get to the Structure 3’s desired field by following that “path” of offsets, you just need to dereference the static address with the offsets you found:Static Memory -&amp;gt; (Structure 1 + 0x14) -&amp;gt; (Structure 3 + 0x4) -&amp;gt; Desired field Dereferencing the memory values from the static memory is HunterPie’s main way to extract the data from the game, it is constantly reading the game’s memory and updating the values internally.DLL InjectionSometimes you want to access the process’s data that is not in memory, in Monster Hunter Rise, for example, the player’s damage is not stored in memory, so scanning the memory for them is not possible.One of HunterPie’s core feature is to be able to track and plot the player’s damage on screen, for that to work properly I had to use another technique. Code injection and function hooks!InjectionThere are a couple of ways to inject code into other processes, but the easiest is to use Window’s kernel32. It has some very useful functions that can be used for this purpose: Open a handle to another process (OpenProcess) Allocate memory in another process (VirtualAllocEx) Write to another process’s memory (WriteProcessMemory) Load library from a path (LoadLibraryW) Create threads in another process (CreateRemoteThread)These 5 steps allow you to inject a library, you start by opening a process handle, allocating enough memory to be able to write a path to your DLL file, writing the string, finding the remote process’s LoadLibraryW address and then creating a remote thread using that LoadLibraryW as start address and the injected string as a parameter.That will make the remote process load the library you want.Function HooksFunction hooks, also known as trampoline or detouring, is a very useful technique to make a process execute code whenever a built-in function is called. If you’re interested on details on this one, take a look at MinHook.Basically it replace the first couple instructions from a procedure with a jmp instruction pointing to a relative address to where your function is, and then another jmp on your detoured function to jump back to the original instructions.This technique allows you to execute code that receives the same parameters as the original function or even change behavior of the original function.HunterPieNow that you’ve seen the basics on how to extract values from another process, it’s easier to explain HunterPie’s architecture.The application is split up in 4 modules: Core, UI, Integrations and HunterPie itself. Core: Contains the application domain entities, this includes common interfaces, configuration definitions, event models, and services that can be used by other modules. Integrations: This is the module that handles the logic for scanning each game, it’s responsible for implementing the interfaces that are on Core. UI: As the name implies, it’s the module responsible for UI related things such as visual controls, data converters, views and view models. The UI module is agnostic to the game integrations which makes the overlay components fully reusable independently of the game. HunterPie: This is the program itself, it is responsible to initialize all the other modules and handle internal features.HunterPie follows an event-based architecture model, there are events for everything that have the possibility of changing. Whenever you start a supported game, a new IContext is instantiated, that interface contains ways to access player, enemies and also game data through the IPlayer, IMonster and IGame interfaces.The previous interfaces are responsible for update values internally and also dispatch events for those values.For example, to start receiving events of the player’s level, you can just subscribe to the OnLevelChange event.[...]private void SubscribeToEvents(IContext context){ context.Game.Player.OnLevelChange += (source, args) =&amp;gt; { Log.Info($&quot;The player is now level {args.MasterRank}&quot;); }}[...]Whenever HunterPie detect that the player’s level changed in-game, it will update the internal value in the IPlayer class and dispatch the event to all its subscribers.Detecting values changesHunterPie tracks values using two different approaches, the first one is by constantly scanning the game’s memory for static addresses and offset paths to the data it needs to works. The second one is by injecting a native library inside the game and opening a communication layer between HunterPie and the game.Memory scanningEvery supported game has a map file containing addresses and offsets that can be used, the map file looks something like this and is loaded in runtime whenever the game starts.# AddressesAddress QUEST_DATA_ADDRESS 0x506F240# OffsetsOffset QUEST_STATE_OFFSETS 0x54 # This supports an array of integers tooThen in the scanner implementation you can fetch those values and read the memory with any type you want, this includes reading complex structures to reduce the amount of P/Invoke calls when reading multiple values.[ScannableMethod]private void GetQuestState(){ var questState = (QuestState)Memory.Deref&amp;lt;int&amp;gt;( AddressMap.GetAbsolute(&quot;QUEST_DATA_ADDRESS&quot;), AddressMap.Get&amp;lt;int[]&amp;gt;(&quot;QUEST_STATE_OFFSETS&quot;) ); QuestStatus = questState.ToStatus(); IsInQuest = questState == QuestState.InQuest;}The ScannableMethod attribute on top of the method name allows that method to be automatically injected into HunterPie’s ScanManager, the scan manager will run all scannable methods in a background thread every couple milliseconds (this can be configured by the user). It also handles failures and has an internal “circuit-breaker” strategy to remove troublesome scannables if they fail too often.Handling failures is a mandatory thing, sometimes process pointers are not valid anymore and HunterPie can read garbage values that could cause a crash if not handled correctly.Native InterfaceThe second value tracking strategy is through a native interface, first HunterPie injects a statically linked library into the game. Once this library is loaded, it automatically opens a TCP socket server that starts listening for incoming connections from HunterPie.To exchange data between the HunterPie application (made in C#) with HunterPie’s native interface that is injected into the game (made in C++), they use a binary protocol, the messages look like this:namespace Core::Server::Models{ typedef uint32_t IPCMessageVersion; enum IPCMessageType { INIT_IPC_MEMORY_ADDRESSES, INIT_MH_HOOKS, GET_HUNT_STATISTICS, DELETE_HUNT_STATISTICS, CLEAR_HUNT_STATISTICS, UNKNOWN }; struct IPCMessage { IPCMessageType type; IPCMessageVersion version; };}Every message will receive the IPCMessage structure as its first field, allowing HunterPie to call the right MessageHandler based on the IPCMessageType and IPCMessageVersion.The OverlayThe overlay is one of HunterPie’s main features and is also the most used one, the architecture is very similar to Model View ViewModel (MVVM) pattern but instead of having a “Model”, HunterPie has what I call IContextHandler. The Views is responsible for the UI itself, it’s what the user will visualize; The ViewModel is responsible to control the data the View will display through data bindings; The IContextHandler is the one responsible to subscribe and handle HunterPie game context’s events. It has direct access to both the View and to the ViewModel it is controlling, but they cannot see the IContextHandler.This architecture makes it really easy to test how the UI is behaving since we can easily create a mock the IContext and simulate in-game changes.The overlay is composed by Widgets, each Widget has its own scope and responsibility, you can have the Monster Widget, that is responsible to display Monster’s information, the Damage Meter Widget that displays the damage done by the players in your party, the Abnormalities Widget that tracks and displays your buffs and debuffs timers, and so on.Every Widget is agnostic to what game you are playing, so it doesn’t matter whether you’re playing Monster Hunter World or Monster Hunter Rise, the Widget components will be reused for both games.Hunt ExportsAnother cool feature, although very recent, is the ability to export hunts. Since HunterPie is constantly tracking in-game information, it is able to track vital information to build a history graph of what happened in your game session.It displays the party members, their damage over time and the (de)buff uptimes. This is possible because since HunterPie follows an event-based architecture, it can “recreate” what happened in-game based on the order that HunterPie’s internal events were dispatched!At the end of every hunt, HunterPie will automatically serialize that data and upload it to HunterPie’s backend and link the upload to the user’s account.ConclusionsHunterPie has been released 4 years ago, the current architecture was very different years ago and is the result to solve solutions I had in the past due to a not well-thought-of architecture. It also took me years to learn things I know now about reverse engineering now, but one thing I can say is that the process of learning all of it was very fun, interesting and changed the way I see software engineering nowadays." }, { "title": "HunterPie v2.8.0", "url": "/posts/update-v2.8.0/", "categories": "Update, v2", "tags": "", "date": "2023-04-19 13:54:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon! HunterPie Account - Hunt ExportThe Hunt Export dashboard has been added, it is still a very new and will be actively worked on in the upcoming updates, the goal is to make it as accurate and useful possible, with uptimes, damage points, information from party members, monsters, quest details, etc.As of today, it currently displays: Quest time Real hunt time (how long it actually took to hunt down a monster) DPS graph Party members Enrage uptime for each monster Abnormalities uptimes Quest details Attention: Exported SOS quests are still not accurate due to how they work. That will be worked on in the future.For more information about this feature, refer to the documentation." }, { "title": "The development of HunterPie", "url": "/posts/development-of-hunterpie/", "categories": "Blog, UI", "tags": "", "date": "2023-03-28 13:43:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!Some contextI have been actively developing and maintaining HunterPie and all its dependencies for about 4 years now, the reason why I’m writing this post is not only to show the progress of HunterPie itself, but to also document the progress I had as a software engineer myself.How it all started…It all started back in 2018 with Monster Hunter World, at the time there was 2 overlays that people used: Smart Hunter and Hello World; As someone who is interested in UI and good looking applications, none of them really stood out to me, not only that, but both of them were pretty limited and not really user friendly, in order for you to customize them, you would need to open JSON files in your text editor.With that in mind, I decided to make my own, not only to make something that would look better to me, but that would also help me learn more about software engineering, reverse engineering, UI/UX principles and so on.First IterationsHunterPyHunterPy was made in Python (hence the Py at the end), a dynamic programming language that is really easy to understand due to its simple syntax, however, is not the best language to make good looking UIs and also not the best language to deal with memory reading, the heart of HunterPie. Despite those, I learned a lot while developing it and used a lot of the fundamentals to implement the next iteration of HunterPie.After some time working on HunterPy, I had a simple overlay working pretty alright, all it had was monster health bars but it was enough to get some friends to use it and test it for me. HunterPy user interfaceSome key features that I always wanted to keep were: Discord Rich Presence The overlay A console Settings that you could interact with, instead of a configuration.json fileOne of the problems with making windows with Python is that you can’t just compile the whole software into a single executable due to how Python works, there are some solutions but they generate a bunch of extra files or huge binaries that would be really painful to distribute if I ever wanted other people to use it.That’s when I decided to rewrite everything in another language, something I could compile and just distribute in a nice little package without worrying too much about the package size.The first iteration…The reason why HunterPie is called HunterPie is because it didn’t make sense to keep the Py suffix anymore as the application was no longer being developed in Python, but I really liked how HunterPy sounded, so I just changed the suffix to keep the same sound without making a reference to Python.The next iteration of HunterPie’s user interface looked like this: HunterPie v1 alpha client HunterPie v1 alpha client settingsThe monster widget looked like this: HunterPie v1 alpha Monster WidgetThis iteration had not only the monster health bar, but also the Harvest Box tracker and Specialized Tool trackers.…the next iteration…The next iteration happened 4 months after the first release of HunterPie v1.0.0.0. I learned a lot more about the UI framework I was using and completely designed the client, not only that but I also created my own UI components for the settings window. This next iteration also had more features like: full localization support so other people could localize HunterPie to their languages; a damage meter widget and the abnormalities tracker widget. HunterPie v1 client HunterPie v1 client settingsThe two main widgets of HunterPie looked like this: HunterPie v1 Monster Widget HunterPie v1 Damage Meter WidgetThe design for the Damage Meter was inspired by Shinra Meter, a TERA damage meter overlay that I used a lot when playing the game back in the days.…and the last iterationThe last iteration of HunterPie v1 happened a few months after the previous one, at that point HunterPie had many new features, new widgets for the overlay, it could export the player’s current build to Honey Hunters, export all the charms and decorations your character had, it also had plugins support, HunterPie Native was also a thing, a way that HunterPie was able to communicate directly with the game which allowed many pretty cool things to happen.In this iteration the design structure of the client didn’t change much, but the colors and the settings page did.I wanted a cleaner design for the client, and changing the colors to a baby blue instead of red made things look more modern and less aggressive, not only the accent color changed but HunterPie’s logo also changed to be white instead of red. HunterPie v1 last iteration clientAdding a blur effect to the background also made the client to look more modern, similar to Windows’s native acrylic effect.As for the settings page, having every setting in a single component was getting way too cluttered and messy, so I added different tabs for each one of the features, the settings were also aligned in a way so the setting label would be anchored to the left and the actual control for that setting would be on the right-most side, that was a way to solve the weird alignment of the previous iteration. HunterPie v1 last iteration client settingsThe main widgets design also changed, the Monster Widget had another design overhaul to look more simple and modern: HunterPie v1 last iteration Monster WidgetAnd the damage meter got a damage graph! HunterPie v1 last iteration Damage Meter WidgetHunterPie v2The reason why I started rewriting HunterPie from scratch to what would become v2 is because its predecessor had a really messy code base, it got to a point where adding new features was really hard and adding support for the upcoming game (Monster Hunter Rise) would be actually impossible. Everything in v1 was heavily tied to Monster Hunter World, not only that but the whole UI was strongly tied to HunterPie’s core code.So for v2 I decided to fix some issues legacy had: The client UI had to look more modern and clean: I don’t think legacy’s UI was bad, but I don’t think it was great either. The settings page to be generated automatically: This is one of legacy’s biggest issues for me as a developer, every time I added new settings I had to also create the UI components for it manually. The settings should be saved automatically on change: Legacy couldn’t detect if the settings were changed, so the user had to click on the Save button every time they made changes. Support any Monster Hunter game: Legacy could only support Monster Hunter World. Write the code in a way that Core code is separate from the UI code: Legacy code didn’t have this distinction, core code could access the UI’d and vice-versa.I will explain each one of those points and how I solved them in a later post, but here’s the result: HunterPie v2 clientThe first thing you can notice is how the colors are much more consistent, they make sense together, it’s no longer a mix of warm and cold colors. The icons are also perfectly aligned now, and they’re all consistent and match the rest of the UI.As for the settings window, I kept the same idea and structure of its predecessor, however it is now possible to search for settings by their label. HunterPie v2 is also capable of automatically saving the settings whenever something changes, so there’s no need for a Save button anymore. HunterPie v2 client settingsNow for the two most used overlay widget, the monster widget got a design overhaul to match the rest of the client UI, in fact, all widgets have gotten a design overhaul to make the UI consistent amongst themselves: HunterPie v2 Monster WidgetAnd the damage meter had a lot of UI improvements too: HunterPie v2 Damage Meter WidgetFinal ConsiderationsThere were a lot of enhancements to HunterPie’s user interface throughout time, most of the things were just trial and error, see what works and what does not. Some came with time and experience after I started working as a software engineer and started having more contact with real world software.The user interface is just the tip of the iceberg for HunterPie, there’s a lot going on behind it, a lot of time and effort put into researching the games, designing and coding HunterPie’s UI, coding internal things used in the core of HunterPie, coding the native part that is required for some features, coding the backend, maintaining all the infrastructure, etc.And of course, each one of those individual pieces that make HunterPie work the way it does deserve their own post. Fun fact: I have spent +2,1K hours on HunterPie (Client and Server) and a couple hundred hours reverse engineering both Monster Hunter World and Monster Hunter Rise. Which is kinda insane, honestly." }, { "title": "Hunt Export", "url": "/posts/hunt-export/", "categories": "Documentation, Account, Feature", "tags": "", "date": "2023-03-27 14:09:00 +0800", "snippet": "AboutHunt export is one of HunterPie Accounts feature, it will automatically keep track and upload all quests you complete successfully, keeping a history of all your previous hunts.The hunt export is separated into two pages, the summaries and the dashboard.SummariesThe summaries page displays all the hunts that are available for you to visualize in the dashboard. Note that the amount of hunts are limited by your account tier.Account Tiers Tier Access Free Up to 7 days of hunts. Low Rank ($1) Up to 30 days of hunts. High Rank ($5) Unlimited Tempered ($10) Unlimited Arch-Tempered ($20) Unlimited DashboardThe dashboard is where you can visualize the details of the hunt, this includes: Damage over time; Moving average DPS Monster’s health over time Enrage uptimes and activation spans; Abnormalities uptimes and activation spans; Party members; Other information about the quest and monsters; Note: More information will be added in the future, this includes deaths and more detailed information about damage and weapon attacksKnown Issues Quests that were joined mid-hunt are not tracked properly Otomos are not displayed Really old exported hunts have 100% enrage uptimes" }, { "title": "HunterPie v2.7.0", "url": "/posts/update-v2.7.0/", "categories": "Update, v2", "tags": "", "date": "2023-02-10 07:23:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!HunterPie v2.7.0 is finally here with a lot of new features! HunterPie Account - Hunt ExportThe Hunt Export is a feature that will be split in two parts, the first one is coming on this version of HunterPie, it consists of tracking your hunt data and once the quest is over, exporting it and linking it to your HunterPie account so you can see that data in a dashboard.The second part of this feature will come on v2.8.0, which is the actual UI that you can use to visualize the exported data.Here’s a sneak peek of the dashboard that will be released in v2.8.0: Note: The UI in the video is not the final result and WILL be changed to look better. It is also possible to turn off this feature if you’re not interested in getting your hunts uploaded. HunterPie Account - Settings Sync HunterPie is now able to synchronize your local settings so you should never lose your settings again Damage Meter Widget HunterPie is now able to track companion’s damage Activities Widget Added Harvest Box tracker for Monster Hunter World Added Argosy tracker for Monster Hunter World Added Steamworks tracker for Monster Hunter World Added Meowmasters tracker for Monster Hunter World Note: It is also possible to turn off activities separately if you are not interested in seeing one of them Abnormalitites WidgetAdded support for new abnormalities: Monster Hunter Rise: Minor Bubbleblight Dango Defender Frenzy Immunity Leeched Sharpness Extension Dango Hunter Dango Connector Agitator Defiance Interpid Heart Heroics Peak Performance Dragonheart Pre-Sleep Health Regen. (Bleed) Powder Mantle (Red) and (Blue) Strife (S) and (L) Maximum Might Berserk Status Trigger Monster Hunter World: Demondrug Mega Demondrug Armorskin Mega Armorskin Bug Fixes Fixed bug where HunterPie would remove the last players from party if someone else dropped the session in Monster Hunter World Fixed bug where HunterPie would not detect multiple players with the same name Fixed bug where HunterPie would fail to reach the backend if header had a new line character in it Fixed bug where HunterPie would try to hash all files during self-updates instead of only the required files for the update" }, { "title": "Troubleshooting", "url": "/posts/troubleshooting/", "categories": "Documentation, Issues", "tags": "", "date": "2022-11-27 01:43:00 +0800", "snippet": "Memory DumpDebugging software without any data that can be analyzed is really hard, so if your HunterPie is constantly freezing, you can try generating a memory dump of HunterPie’s process so I can analyze it and see if there’s anything weird going on. To generate a memory dump, do the following: Open the command prompt by opening Windows’s search and typing cmd Run the following command dotnet tool install --global dotnet-gcdump Once the tool finishes installing, open Windows’s Task Manager (Ctrl+Shift+Esc), click on the Details tab and look for a HunterPie.exe, the details tab should have a column labeled as PID, you’ll need to grab HunterPie’s PID. Run the following command, replacing &amp;lt;PID&amp;gt; with HunterPie’s actual PID that you got from the previous step: dotnet gcdump collect -p &amp;lt;PID&amp;gt; It will print something like:Writing gcdump to &#39;&amp;lt;PATH_TO_GCDUMP_HERE&amp;gt;&#39;... Finished writing &amp;lt;NUMBER_OF_BYTES&amp;gt; bytes.Now that you’ve dumped HunterPie’s memory to a .gcdump file, just send that file to me on Discord: Haato#0001 or in HunterPie’s official server." }, { "title": "Player Hud Widget", "url": "/posts/player-hud-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-11-27 01:43:00 +0800", "snippet": "The Player Hud Widget is responsible for tracking and displaying the data related to your character’s health and stamina, as well as tracking your weapon’s sharpness.Widget StructureHealth barThe health bar can be broken down into 5 pieces: Maximum Possible Health: This is the white bar that’s behind all the other bars, it represents your maximum possible health, in Monster Hunter Rise, this is the bar that shows how much your actual health can be expanded to by consuming the green birds. Max Health: This is represented by the dark bar behind the recoverable health, heal and health. Recoverable health: This is your health that can be recovered naturally over time. Heal: This is the bar that will represent the healing when you’re consuming an item that can heal your life, it’s represented by the light green bar. Health: This is your actual health, it’s represented by the green bar.Stamina BarThe stamina bar can be broken down into 4 pieces: Maximum Possible Stamina: This is the maximum possible stamina you can have, it’s represented by the white bar that’s behind all the other bars. In Monster Hunter Rise, this is the bar that shows how much your actual stamina can be expanded to by consuming the yellow birds. Max Stamina: This is the bar that shows you what’s your current maximum stamina, represented by the dark bar behind the stamina bar. Recoverable stamina: This bar will show how much stamina you can recover by eating rations or meat, it’s represented by the hollow bar with the red border around it. This only happens in Monster Hunter Rise. Stamina: This is your actual stamina, it’s represented by the orange-ish bar.AbnormalitiesWhen your character is suffering from a debuff, your health bar or stamina will change it’s color to match the element that is currently active. Fire Poison Bleed Nat. Heal Water Ice Effluvia SharpnessHunterPie tracks your sharpness, and displays it in a gauge. The colors for each level are the following: Red Orange Yellow Green Blue White Purple It’s also possible to override those colors with theme files, in case you want custom colors for each level.&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_BROKEN&quot;&amp;gt;#000000&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_RED&quot;&amp;gt;#D13232&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_ORANGE&quot;&amp;gt;#F78B00&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_YELLOW&quot;&amp;gt;#F7E024&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_GREEN&quot;&amp;gt;#5BF77F&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_BLUE&quot;&amp;gt;#49B2E3&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_WHITE&quot;&amp;gt;#EAF5F4&amp;lt;/Color&amp;gt;&amp;lt;Color x:Key=&quot;WIDGET_SHARPNESS_PURPLE&quot;&amp;gt;#cd55e6&amp;lt;/Color&amp;gt;In-Game HUDTo avoid cluttering the screen, you can disable the in-game HUD:Monster Hunter Rise" }, { "title": "HunterPie v2.6.0", "url": "/posts/update-v2.6.0/", "categories": "Update, v2", "tags": "", "date": "2022-11-27 01:18:00 +0800", "snippet": " If you enjoy HunterPie and want to support its development, consider supporting on Patreon!HunterPie v2.6.0 is finally here with a lot of new features! Player HUD WidgetThis new widget is responsible for displaying your character’s health, stamina and sharpness in a simple health bar, it also displays how many hits you have left until your sharpness level decreases.The widget’s design is the following:You can also see it in action in the video below:The player HUD does not display buffs on top of the player’s health bar, for that you need to use the Abnormalities Widget. Tip: Refer to the documentation for more information. OptimizationsThis update also brings some minor and major optimizations to HunterPie, below you can see the benchmark comparing both the old scanning method and the new one.Although the new implementation is only 12% faster, it is a lot more stable when you compare the slowest scan passes compared to the old implementation. Other changes Added hotkey to toggle overlay (default: Ctrl+Alt+O); Added support for new abnormalities: Adrenaline Rush, Sleep, Stun, Paralysis; HunterPie now downloads localization files from the CDN instead of updating them only during updates; Apex monsters no longer display the capture icon; Introduced Smart Events to handle internal events within HunterPie’s core; Bug Fixes Fixed memory leak due to smooth bar animations; Fixed memory leak due to internal events not being unsubscribed on game exit; Fixed Qurio part health displaying even when Qurio wasn’t active for that specific part; Fixed HunterPie crashing when loading an invalid theme file; Fixed HunterPie crashing or throwing a lot of exception messages in the console during the scanning process; Fixed HunterPie not cancelling self-update when binaries are not downloaded successfully;" }, { "title": "HunterPie v2.5.0", "url": "/posts/update-v2.5.0/", "categories": "Update, v2", "tags": "", "date": "2022-11-03 06:29:00 +0800", "snippet": "HunterPie v2.5.0 is finally here with a lot of new features! Monster Widget - QurioHunterPie now supports Qurio monsters: Added Qurio Threshold bar; Added support for Qurio parts; Added Qurio monster icon; Before entering Qurio state After entering Qurio state Abnormalitites WidgetAdded support for the following abnormalities: Monster Hunter Rise: Sunbreak Bloodblight; Grinder (S); Coalescence; Demondrug; Mega Demondrug; Armorskin; Mega Armorskin; Damage Meter Added maximum deaths for quest; Patch Notes TabHunterPie has a new dedicated tab for the latest patch notes. Bug Fixes Fixed Capture indicator appearing for Qurio monsters; Fixed submarines total item count miscalculation; Fixed bug where HunterPie wouldn’t retry requests in case of timeout;" }, { "title": "HunterPie v2.4.0", "url": "/posts/update-v2.4.0/", "categories": "Update, v2", "tags": "", "date": "2022-10-13 02:16:00 +0800", "snippet": "HunterPie v2.4.0 is finally here with a lot of new features! AccountsHunterPie accounts will be part of HunterPie’s core features, although it is not required to have one to use the overlay, HunterPie will be getting more account-related features in the upcoming updates. Here are some of the planned features that will require an account: HunterPie configuration cloud synchronization; Hunt details; Tip: Refer to the documentation for more information. Game saves backup This feature requires an account.Having a HunterPie account will allow HunterPie to automatically backup your save files and upload them to the cloud. You can read more about the backup feature here. Damage Meter - Monster Hunter World HunterPie can now calculate your damage when in expeditions and Guiding Lands. Warning: This feature requires Stracker’s loader to work properly. UX enhancementsHunterPie’s client animations have been reworked and some new animations have been added when interacting with the main client window. Added transition animations when opening different views in the main window; Added animations to tooltips when hovering over UI components; Added smooth scrollbar; Added fade-in and slide-in animations to setting elements when changing setting tabs; Changed button colors and rounded their corners; Added Github button to the sidebar container; Bug Fixes Fixed a bug where Meowmasters step counter would show as 6/5 when Meowmasters are back in town." }, { "title": "HunterPie Account", "url": "/posts/account/", "categories": "Documentation, Account, Feature", "tags": "", "date": "2022-10-10 14:08:00 +0800", "snippet": "AboutHunterPie Account is one of it’s core features, although not necessary, it’s highly recommended to have an account because that way you can use HunterPie at its fullest.Exclusive FeaturesHaving an account will give you the access to the following features: Hunt Export: Your hunts will be tracked and uploaded so you can visualize them in a dashboard. You can read more here Remote HunterPie settings: Your configurations will be tied to your account instead of being saved locally only. Automatic game saves backup: HunterPie will automatically backup your game saves and upload them to the cloud. You can read more here Note: More account-exclusive features will be added in the future.Creating an account Click on the Sign Up button in your HunterPie’s side bar; Fill the required information and click on the Register button; HunterPie will automatically send you an email to verify the email associated to your account; After verifying the email, you can now login into your account! Warning: The process of receiving a verification email should be instant but might take a few minutes depending on your email provider. Make sure to also check your spam and trash folders.Supporter AccountYour account will be automatically turned into a supporter account if you create it using the same email you used when creating your Patreon account. By being an active supporter you also get access to BETA updates and upgrades to some of the existing features.Supporter TiersThere are 4 different supporter tiers, depending on your tier, you will get an enhancement to the existing HunterPie features. The available tiers can be found here." }, { "title": "HunterPie Account - Saves Backup", "url": "/posts/saves-backup/", "categories": "Documentation, Account, Feature", "tags": "", "date": "2022-10-10 13:33:00 +0800", "snippet": " This feature can be disabled in your account settings.One of the features of having a HunterPie Account is that HunterPie will automatically backup your save and upload it to the cloud, this way you can play Monster Hunter games without worrying about your save getting corrupted.The backups are available under your account details screen.How it works?HunterPie will automatically handle backups of your game saves, the limit on how often and how many backups you can have at once depends on your type of account. Account Number of Backups (total) Rate limit Standard 2 backups (total) Once every 72 hours Supporter 5 backups (total) Once every 24 hours Backup list You can download the backup file by clicking on the button, HunterPie will download the file into the HunterPie/Backups folder as a .zip file. To open the Backups folder quickly, you can also press the button. In case you want to manually delete a backup file, just click on the button. Warning: Keep in mind that deleting a backup file manually WILL NOT reset your rate limit." }, { "title": "HunterPie v2.3.0", "url": "/posts/update-v2.3.0/", "categories": "Update, v2", "tags": "", "date": "2022-08-24 12:54:00 +0800", "snippet": "HunterPie v2.3.0 is finally out and brings new features and fixes! Themes Added theme support, it is now possible to fully customize every Widget appearance. Activities Widget Added Meowmasters tracker. Added Cohoot Nest tracker. Minor design changes to the widget components. Activities Widget Damage Meter Widget Added Master Rank to be displayed on top of the player’s weapon icon. Added Otomo’s damage tracker. Bug Fixes Fixed Chat Widget. Fixed bug where HunterPie would crash if someone left the party unexpectedly. Fixed bug where DPS would be recalculated if a party member changed their weapon in the tent." }, { "title": "HunterPie v2.2.0", "url": "/posts/update-v2.2.0/", "categories": "Update, v2", "tags": "", "date": "2022-07-20 13:18:00 +0800", "snippet": "HunterPie v2.2.0 is finally out and brings a lot of new features and enhancements!General Upgraded required .NET version to 6.0, you can download it from here. Added support for the following Monster Hunter Rise abnormalities: Chain Crit (Under armor skills) Stinkmink (Under consumables) Added option to configure animations framerate Added localization for enumerations Added Master Rank to Discord Rich Presence for Monster Hunter Rise Minor optimizations to widgets Changed abnormality settings tab icon to a proper iconDamage Meter WidgetOne of the most asked features is now available for Monster Hunter Rise! The Damage Meter tracks yours and your team mates damage and display it in a modern-looking meter and plotting graph. The following strategies were added to the damage meter graph: Plot by total damage Plot by DPS The following strategies were added to the DPS calculation: DPS relative to join time DPS relative first hit DPS relative to quest timer The way how HunterPie calculates the damage done by each player is by looking at each individual hit and summing them up, right now it will ONLY considerate the damage done by each player’s weapon. The following damages are not accounted for when calculating damage done by each player: Environmental damage Damage done by other monsters Damage done by ailments (e.g: Poison, blast, etc) Note: Damage calculation may change in the future. Tip: Refer to the documentation for more information.Monster Widget Added monster weaknesses Added capture indicator Tip: Refer to the documentation for more information.HunterPie Native InterfaceHunterPie Native Interface is responsible for sending data from inside the game’s process to HunterPie, this is required for features that depends on function hooking such as Monster Hunter Rise damage meter.Bug Fixes Fixed unmapped part names for some monsters in Monster Hunter: World Fixed memory leak due to in-memory custom font Fixed enrage counter Fixed HunterPie logo asymmetry Fixed widgets not being closed properly after Monster Hunter World is closed" }, { "title": "Specialized Tool Widget", "url": "/posts/specialized-tools-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-06-16 22:00:00 +0800", "snippet": "The Specialized Tool Widget is responsible for tracking and displaying your specialized tool (or mantles) cooldown and timers. HunterPie offers two different modes for the Specialized Tool Widget: Compact Mode; Detailed Mode;Compact ModeThis mode is for people who are only interested in the timer and cooldown of their tools.Detailed ModeBesides the information that compact mode also shows you, detailed mode also shows the name of the specialized tool." }, { "title": "HunterPie v2.1.0", "url": "/posts/update-v2.1.0/", "categories": "Update, v2", "tags": "", "date": "2022-06-15 10:57:00 +0800", "snippet": "HunterPie v2.1.0 contains the second part of the full Monster Hunter World support.General Added supporter badge on top of the HunterPie’s window. HunterPie no longer saves its configurations on exit. Adjusted HunterPie settings window margin. Adjusted Damage Meter icon in the settings window.Monster Hunter: WorldMonster Widget Added tenderize information to monster’s part health bars. Severable and normal parts now have different colors.Specialized Tool WidgetThe specialized tool widget is the one responsible for showing your primary and secondary specialized tool cooldown and timer. Tip: Refer to the documentation for more information.Bug Fixes Fixed a bug where widgets wouldn’t be hidden in NPC dialogs even when the “Hide when HUD is open” option is enabled in Monster Hunter Rise. Fixed a bug where HunterPie would crash if there were duplicate constant names in the map file. Fixed a bug where Training Dojo state bar size would go back and forth when there were 0 days left for training." }, { "title": "Damage Meter Widget", "url": "/posts/damage-meter-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-06-15 10:21:00 +0800", "snippet": "The Damage Meter Widget is responsible for tracking and displaying yours and your party members damage and damage per second, as well as plotting everything in a graph for better understanding of your hunts.UI Design Damage Meter WidgetDamage AccuracyMonster Hunter WildsFor Monster Hunter Wilds, the damage is tracked in two different ways: If the player is in a quest, the quest award damage value will be used. This value is synchronized with every party member, which means it is the most accurate value possible and everyone in the party will receive the actual damage each party member dealt. The limitation is that it: Only works in normal quests, arena quests do not count. The value will be updated only once every 5 seconds for remote players and in real time for the local player. As a fallback, if there is no accurate damage value available, the not-as-accurate value will be used. This value is always calculated by your game regardless if you’re the host or not, and since it is not synced amongst party members, the value can have some inconsistencies when comparing to the meter of other players.In both cases, your own damage is always accurate. Only damage coming directly from weapons are accounted for, this is how the game handle these damage calculations. HunterPie DOES NOT calculate anything, it just displays the values that your game calculates.Monster Hunter WorldThe damage for World is calculated by the game itself, it is the same damage that is used in the quest awards screen (after finishing the quest). Since this is a value synced with every player in the party, the damage for each player will be the same regardless if you’re the host or not.In the case of expeditions, guiding lands and missions that have no target (Kulve Taroth Siege), the damage is not tracked by the game, HunterPie will use its fallback implementation. The fallback can only track the local player’s damage, this is a game limitation.Monster Hunter RiseTo calculate the damage for Monster Hunter Rise, HunterPie will sum every hit damage and assign it to whoever did the damage. This does not consider: Environmental damage Damage done by ailments (e.g: poison, blast) Damage done by other monsters Hitting a dead monster will still count as damage done to a monster. This is a known issue and will be fixed eventually.SettingsPlayer colorsYou can change yours and your party members color by going to the settings tab and clicking on the color configuration.Damage plotMoving Average DPSHunterPie will display the moving average DPS by default, the moving average is more useful than the overall DPS plotting because the overall DPS tends to stabilize in the long run. moving average DPS vs Overall DPSIt is highly recommended to use the moving average, however it is also possible to toggle it off and plot either overall DPS or total damage. Changing the plot mode while in a hunt will not update the previous points that were already plotted in the graph.DPS CalculationBy default, HunterPie will calculate the damage per second based on the quest timer, however, this can be inaccurate especially when joining in-progress quests (such as SOSes), you can change the DPS calculation strategy in the Damage Meter settings. Strategy Description Relative to quest The quest timer will be used to calculate players DPS Relative to join The time when each player joined the quest will be subtracted from the quest timer when calculating players DPS Relative to first hit The time when each player hit a monster for the first time will be subtracted from the quest timer when calculating players DPS " }, { "title": "HunterPie v2.0.23", "url": "/posts/update-v2.0.23/", "categories": "Update, v2", "tags": "", "date": "2022-05-02 03:51:00 +0800", "snippet": "HunterPie v2.0.23 contains the first part of the full Monster Hunter World support.General Changed Mount ailment name to Ride for Monster Hunter Rise Changed visual component for hotkeys Changed visuals of ComboBox Changed HunterPie client color scheme to be more consistent Added Offensive Guard abnormality for Monster Hunter RiseConfigurationSince HunterPie can support multiple games, it allows you to configure games separately, so you can have a different overlay configuration for each game.Choosing which game to configure is rather simple, just choose the game by its name in the box in the bottom of HunterPie’s settings window.Monster Hunter: WorldOne of the main reasons HunterPie v2 exists is to support multiple games from the Monster Hunter series, this update brings support for Monster Hunter: World and some of the main overlay Widgets that v1 has at the moment.OverlayMonster WidgetCompared to HunterPie legacy, the monster widget now has 100% accurate lockon detection, supports more than 3 monsters. Tip: Refer to the documentation for more information.Abnormalities WidgetRight now, HunterPie supports most of the abnormalities Monster Hunter: World has, with exception of potions that last forever like Demondrug and Armorskin. Tip: Refer to the documentation for more information.Damage Meter WidgetThe damage meter is something that’s part of the core of HunterPie legacy, in v2 there were a lot of enhancements: Quest timer is now 100% accurate and displays the right time even for in-progress quests (like SOSes)." }, { "title": "Chat Widget", "url": "/posts/chat-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-04-01 10:54:00 +0800", "snippet": "The Chat Widget is responsible to display in-game messages from other players.Widget StructureWhy does it exist?Monster Hunter: Rise’s built-in chat was made for Switch and not for PC, making it really difficult to read messages and also keep track of them. Whenever you get a message, it stays on screen for about 10 seconds and then fades away, if you want to read the message again, you are obligated to go to your in-game settings, open the chat messages and then open the chat, which can become very annoying if you play online with friends often.HunterPie’s chat solves this issue by showing only the player messages, and it also shows the widget whenever you press Enter to type in the chat. Warning: Preset messages will not be shown in the chat." }, { "title": "HunterPie v2.0.22", "url": "/posts/update-v2.0.22/", "categories": "Update, v2", "tags": "", "date": "2022-04-01 09:28:00 +0800", "snippet": "HunterPie v2.0.22 brings some new features, fixes and optimizations.General Added support for Monster Hunter Rise v3.9.1.0 Added Party state and size to Discord Rich Presence Added option to automatically close HunterPie when game is no longer running Added option to start HunterPie on background Added option to not show confirmation popup on exit Added option to hide individual widgets when the in-game HUD is visible (e.g when you’re in camp, talking to NPCs, with game menu open, etc) HunterPie now updates settings file in real time Optimizations to the UI thread Optimizations to the Scan thread Minor visual enhancedments to the main window HunterPie now displays the last config sync time in the Settings tabActivities WidgetThe Activities Widget tracks and displays your Submarines, Training Dojo and Training buddies data. Tip: Refer to the documentation for more information.Chat WidgetThe Chat Widget displays messages from your chat so you won’t lose track of them during a hunt. This widget is designed to only show actual messages, no NPCs, no system messages nor notifications from the game. Tip: Refer to the documentation for more information.Abnormalities Widget Added Protective Polish Added Arc Shot: Brace Added Arc Shot: AffinityBug Fixes Fixed a bug where HunterPie would still try updating Rich Presence when it’s disabled Fixed bug where HunterPie would crash when trying to unload an unitialized widgets Fixed CDN download causing HunterPie to crash due to unauthorized file access Fixed wrong string for Training Dojo setting Fixed default widget positions Fixed bug where HunterPie would not parse floats separate by comma due to cultural dependent system Fixed memory leak due to garbage memory values in the string lengths, causing HunterPie to read a large array of bytes" }, { "title": "HunterPie v2.0.21", "url": "/posts/update-v2.0.21/", "categories": "Update, v2", "tags": "", "date": "2022-03-02 03:51:00 +0800", "snippet": "HunterPie v2.0.21 brings some new features, fixes and design changes.General Added support for Monster Hunter Rise v3.9.0.0 Added option to patch game function to render the Wirebug aim even when the Wirebug Gauge HUD is disabled. Added option to hide Overlay when the game is not focused. Added option to hide unknown parts (parts labeled as ???). Added Patreon button in HunterPie’s sidebar. HunterPie now reports crashes automatically to the developer. It’s now possible to scale a widget while in design mode by using the Mouse Scroll while hovering on the Widget. It’s now possible to change a widget’s opacity by pressing Ctrl + Mouse Scroll while hovering on the Widget.Wirebug WidgetThe Wirebug Widget tracks and displays all the useful information you need to know about your Wirebugs, as cooldown, timers and if they’re available or not. Its designed to replace the in-game Wirebug Gauge, however, you can also place it on top of the in-game UI too. Wirebug Widget example Tip: Refer to the documentation for more information.ClientThe HunterPie has also gotten a new visual to some elements in it’s client window New console window design New settings window designBug Fixes Fixed bug where HunterPie would try to render an invalid part and throw an error." }, { "title": "Wirebug Widget", "url": "/posts/wirebug-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-27 12:25:00 +0800", "snippet": "The Wirebug Widget is responsible for tracking and displaying all your Wirebugs information as cooldown, timer and if they’re available or not. This widget is quite simple and follows the same design as the in-game Wirebug gauge.Widget StructureIn-Game HUDReplacing the in-game Wirebug Gauge is quite simple, while in-game, open the HUD settings and disable the Wirebug Gauge. Attention: Disabling the in-game Wirebug Gauge also disables the Wirebug aim, to fix this, enable the Patch in-game Wirebug Aim option in your HunterPie’s Wirebug settings." }, { "title": "Localization", "url": "/posts/localization/", "categories": "Documentation, General", "tags": "", "date": "2022-02-18 11:07:00 +0800", "snippet": "HunterPie supports different languages other than English, if you want to localize it to another language make sure to read this because it covers everything you need to know to make your own localization file.LocalizationsThe supported languages are: Language Translated (%) Getting StartedRequirements A decent text editor, I personally recommend: Visual Studio Code Sublime Text Notepad++ The default strings file, you can find it here Tip: Do not use the default Windows’s notepad, that can cause file encoding issues and will make HunterPie fail to load your file. Make sure your encoding file is UTF-8.LocalizingNow thhat you have the requirements, it’s time to start translating!Use the en-us.xml you downloaded in the last step as a base file, it contains all the currently supported strings that are used by both the HunterPie client and the Overlay and the integrations. Warning: Make sure to rename your file to something else so it doesn’t conflict with the default files. If you don’t rename it, there’s a risk your local file will be overwritten during the auto-update process.Do not touch the first line of the XML Document, that is telling our XML parser the version and file encoding we are using. It should ALWAYS be the first line of the file and should always look like this:&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;&amp;lt;!-- Comments can be added ONLY after the tag --&amp;gt;Next step is to set the language name, you can do it in the next Tag by changing the value of the lang attribute.&amp;lt;!-- Before --&amp;gt;&amp;lt;Strings lang=&quot;English&quot;&amp;gt;&amp;lt;!-- After --&amp;gt;&amp;lt;Strings lang=&quot;Japanese&quot;&amp;gt;Now we’re can translate the rest of the file, most localization Tags have three attributes: Id: Used internally by HunterPie to query the string and description. DO NOT TOUCH THIS VALUE String: The actual string that will be shown in HunterPie’s interface. Description: This one is only used in places where there can be a tooltip, e.g: Settings, Buttons Please, try to keep all translations as accurate as possible with the in-game strings (especially abnormalities and monster names). You can shorten long strings as long as they don’t become difficult to understand.E.g:&amp;lt;!-- Before --&amp;gt;&amp;lt;Rise&amp;gt; &amp;lt;Monster Id=&quot;0&quot; String=&quot;Rathian&quot;/&amp;gt; &amp;lt;Monster Id=&quot;1&quot; String=&quot;Apex Rathian&quot;/&amp;gt; &amp;lt;Monster Id=&quot;2&quot; String=&quot;Rathalos&quot;/&amp;gt; &amp;lt;Monster Id=&quot;3&quot; String=&quot;Apex Rathalos&quot;/&amp;gt; &amp;lt;Monster Id=&quot;4&quot; String=&quot;Khezu&quot;/&amp;gt; &amp;lt;Monster Id=&quot;5&quot; String=&quot;Basarios&quot;/&amp;gt; [...]&amp;lt;!-- After --&amp;gt;&amp;lt;Rise&amp;gt; &amp;lt;Monster Id=&quot;0&quot; String=&quot;リオレイア&quot;/&amp;gt; &amp;lt;Monster Id=&quot;1&quot; String=&quot;ヌシ・リオレイア&quot;/&amp;gt; &amp;lt;Monster Id=&quot;2&quot; String=&quot;リオレウス&quot;/&amp;gt; &amp;lt;Monster Id=&quot;3&quot; String=&quot;ヌシ・リオレウス&quot;/&amp;gt; &amp;lt;Monster Id=&quot;4&quot; String=&quot;フルフル&quot;/&amp;gt; &amp;lt;Monster Id=&quot;5&quot; String=&quot;バサルモス&quot;/&amp;gt; [...]XML Special CharactersXML has some characters that should be replaced by their escaped versions in order for it to work. This is because these characters are used in the XML’s structure itself, and the parser has a hard time figuring out whether it’s a XML character or if it’s just a normal character. Character Replaced by &amp;amp; &amp;amp;amp; &amp;lt; &amp;amp;lt; &amp;gt; &amp;amp;gt; ” &amp;amp;quot; ’ &amp;amp;apos; E.g:&amp;lt;!-- This will give us an error --&amp;gt;&amp;lt;Abnormality Id=&quot;ABNORMALITY_ATTACK_DEF_UP&quot; String=&quot;Attack &amp;amp; Def. Up&quot;/&amp;gt;&amp;lt;!-- This will work --&amp;gt;&amp;lt;Abnormality Id=&quot;ABNORMALITY_ATTACK_DEF_UP&quot; String=&quot;Attack &amp;amp;amp; Def. Up&quot;/&amp;gt;Sending my localizationNow that you’ve finished translating all strings, you can open a Pull Request to HunterPie’s repository or send it in the #translation-discussion channel in HunterPie’s official Discord Server. Making your own Pull Request is the preferred way, since it will also mark you as one of HunterPie’s contributors in GitHub, but if you have no Git experience sending the file directly to me on Discord is also fine." }, { "title": "Frequently Asked Questions", "url": "/posts/faq/", "categories": "Documentation, General", "tags": "", "date": "2022-02-17 02:42:00 +0800", "snippet": "Windows is asking me to install .NET 8, what do I do?HunterPie requires .NET 8.0 Desktop Runtime to run properly, you can download it from Microsoft’s official site by clicking here.My antivirus is blocking/deleting HunterPieIt’s just a false positive, HunterPie works by accessing other programs running on your computer (in this case, the game), some viruses also work in a similar way, hence this behavior can be flagged “suspicious”.My overlay is not appearing on top of the gameThis is a known issue in Monster Hunter World when running the game with DirectX 11, either: Enable DirectX 12 API under your game’s graphics settingsOR Run the game in borderless windowed mode.Also, make sure your overlay and any widgets you want to see are actually enabled for that game.Moving and Scaling WidgetsTo move a widget you can either use Design Mode (toggleable by pressing the default hotkey: ScrollLock) or set the absolute coordinates in HunterPie’s settings.To scale a widget, you can go to HunterPie’s settings for that widget and use the Scale slider. For more information about widgets, check the Overlay and Widgets documentations.Why aren’t my settings saving?Make sure your HunterPie’s folder is not in read only mode, if that doesn’t work, try moving your HunterPie folder to somewhere else.If that is not your issue, make sure you’re changing the settings of the correct game, HunterPie supports multiple games and by default it will enter the settings window with Monster Hunter Rise as the default game.My auto update is getting stuckSame as the previous issue, make sure your folder is not in read only mode, also try moving its folder somewhere else.My overlay seems delayedIf you have HunterPie running with Hardware as its rendering strategy and you have Windows’s GPU scheduling enabled, it will cause HunterPie to freeze every now and then because that’s what GPU scheduling does; it pauses the rendering of other applications to give the game more GPU time." }, { "title": "HunterPie v2.0.20", "url": "/posts/update-v2.0.20/", "categories": "Update, v2", "tags": "", "date": "2022-02-17 02:14:00 +0800", "snippet": "HunterPie v2.0.20 brings some new features and fixes.General Patch notes button now opens the current update patch notes in HunterPie’s documentation Added supporter tokens, allowing Patreons to receive beta updates Added some development options to the Advanced Debug ToolsAbnormality TraysAbnormality Trays are bars that track and display your character’s buff and debuff timers, they can be used in case you want to know how long your Hunting Horn buff will last, for example.As of now, HunterPie supports the following categories for buffs, not all of the buffs are supported, but they will be added whenever possible: Songs Consumables (this also includes environment buffs) Debuffs Gear skills Food skills Abnormality tray showing buffs and debuff Refer to the documentation for more information.Monster WidgetNew featuresMonster Widget has gotten some visual enhancements to the parts components, now it displays flinch, break and sever values. Since all parts have flinch values, the bars will still show that info once you can no longer break/sever it. Added horizontal orientation for Monster Widget. Added dynamic resizing for health bars depending on how many monsters the Widget is showing at the moment Added minimum width for Monster health bars Added flinch, severable and breakable partsPartsEach color represents a different type of part: Color Represents Description Flinch Flinch values represent when the monster is going to flinch or get staggered. Break Break values represent when a part is about to break. Sever Severable parts are the ones that can be cut off from a monster. Broken A part will become Grey when it’s either broken or severed. Severable partsSeverable parts are the parts that can be physically removed from the monster’s body, like tail and horns. Severable and Breakable partBreakable partsBreakable parts are the parts that can be broken, showing the “Part was broken” message in the game. Breakable and Flinch part Refer to the documentation for more information.Bug Fixes Fixed Somnacanth part order Fixed wrong Chameleos part order Fixed wrong pointer to monster flinch values, causing some monsters to not show any part data at all. Fixed bug where monsters would not despawn once dead. Fixed bug where HunterPie would show invalid parts before all valid parts. Fixed bug where HunterPie wouldn’t hide monster health percentage in Discord Rich Presence properly Fixed bug where HunterPie would fail to find game process due to cultural differences in UTF-8 characters" }, { "title": "Widgets", "url": "/posts/widgets/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-15 06:03:00 +0800", "snippet": "Widgets are part of HunterPie’s core, they’re the components that hold the widget’s content to display their data to the user.Toggling WidgetsHunterPie allows you to toggle Widgets in two different ways: If you don’t want to see the widget, you can disable the Show Widget option. This will hide the Widget but the Widget will still be created every time you open the game. If you don’t care about a certain widget at all, it is recommended to turn the Initialize Widget option off. This will make it so that Widget won’t be created at all.Adjusting positions and scalesIt is possible to change the Widget’s position, scale and opacity. Position: You can change the values of the X and Y coordinates for the widgets. Note that since it uses absolute positioning, if you set them to something out of boundaries, the widget will also be out of boundaries and will not be visible anymore. Opacity: This option controls the transparency of the whole widget, the values range from 0 to 1 where 0 is 0% visible and 1 is 100% visible. Scale: This controls the vertical and horizontal scale of the Widget, the values range from 0.1 to 2 where 0.1 is 10% of the original size and 2 is 200% of the original size. Although it is possible to change the position and scale directly from the settings tab, it is recommended to do that in the design mode.Dynamic BehaviorsHunterPie provides a way for the widgets to hide themselves whenever the game’s HUD is visible. This setting is independent for each widget, so you will have to enable them individually for each widget you want to become invisible whenever the HUD is open." }, { "title": "Overlay", "url": "/posts/overlay/", "categories": "Documentation, Overlay", "tags": "", "date": "2022-02-14 12:31:00 +0800", "snippet": "Overlay is one of HunterPie’s core features, it is responsible to manage every single Widget.Design ModeDesign Mode makes all Widgets visible to mouse events, making them clickable and allowing the user to interact with them. When Design Mode is active you can drag-and-drop Widgets with your mouse, scale linearly with your mouse scroll and also individually close a widget you don’t want to see anymore.To toggle design mode, you can use ScrollLock or whatever Hotkey you set in your HunterPie’s configuration." }, { "title": "Monster Widget", "url": "/posts/monster-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-14 06:03:00 +0800", "snippet": "The Monster Widget is responsible to track and display all the big monsters information. It is one of the most complex widgets and each single component is designed to be simple without losing information.Widget StructureMonster PartsParts are represented by the blue, yellow and red bars under the ailments component. Their visual representation depends on what type of part it is: Color Represents Description Flinch Flinch values represent when the monster is going to flinch or get staggered. Break Break values represent when a part is about to break. Sever Severable parts are the ones that can be cut off from a monster. Broken A part will become Grey when it’s either broken or severed. Qurio* A part will become Pink when it’s related to the monster’s Qurio state. When a part has all three values, the priority order is always Qurio &amp;gt; Sever &amp;gt; Break &amp;gt; Flinch and the exact values displayed under the part health bar will follow that priority. By default, HunterPie only shows monster’s parts when you have the monster as a target. Read Targeting a monster for more information. A Qurio part is exclusive for Monster Hunter Rise: SunbreakMonster AilmentsAilments are statuses and debuffs you can inflict on a monster, HunterPie supports all of them, however, some of them might display as Unknown since ailments are mapped manually and require testing.They’re designed to be as simple to read as possible, displaying Build Up, Duration and also how many times that Ailment has been activated on that monster. Each ailment has its own individual color to make it easier to know what ailment has been inflicted without having to read its name. By default, HunterPie only shows monster’s ailments when you have the monster as a target. Read Targeting a monster for more information.Targeting a monsterHaving to target a monster to see its information is part of HunterPie’s design to avoid cluttering the screen with multiple monsters information, HunterPie offers a couple ways to target monsters: Lock-on: Uses the game lock-on/targeting system. This is better if you want to have 100% control over HunterPie’s monster target. Inference: HunterPie will calculate a score based on distance, health and how recent was the last damage the monster took. This option is good if you don’t want to manually target anything, however, since it’s based on guessing, it can target the wrong monster in certain conditions. Map Pin: This options uses the map pin mechanic from Monster Hunter World to target the monster. Quest Target: This option only exists for Monster Hunter Rise and will use the quest’s monster as the target.Capture indicatorFor capturable monsters, an upside down triangle () will be placed on the exact percentage where the monster will become capturable.OrientationMonster Widget supports two orientations, Vertical and Horizontal Orientation Description Vertical Monster health bars will be placed on top of each other in the order they spawn Horizontal Monster health bars will be placed side by side in the order they spawn " }, { "title": "Abnormality Tray Widget", "url": "/posts/abnormality-tray-widget/", "categories": "Documentation, Overlay, Widgets", "tags": "", "date": "2022-02-14 00:23:00 +0800", "snippet": "The Abnormality Tray widget allows you to track your buff and debuff durations, it’s useful when playing Hunting Horn, or when you just want to know how long a certain buff will last. HunterPie lets you create as many trays as you want, allowing you to separate abnormalities in different trays. Keep in mind the more widgets you have on your screen, the more it impacts performance.Creating a new trayTo create a new tray, open HunterPie’s settings in the Abnormality Trays tab and click on the , in case you want to delete a specific tray, click on the , it will prompt you with a confirmation so you can delete the tray. If you’re creating new bars while the game is running, you’ll have to restart HunterPie in order for it to visually create the bar widget.Configuring the trayTo configure your new tray, click on the . It will open a new window that lets you configure all the tray settings individually.Enabling abnormalitiesIn the configuration window, there’s a panel with all the available abnormalities, clicking on one of them will automatically enable tracking that abnormality in that individual tray. Icon Description Enabled Disabled OrientationOrientation is the setting that indicates which direction your tray will grow to fit all abnormalities, setting it to Horizontal will make the tray grow sideways until it reaches its maximum width, on the other hand, Vertical will make the bar grow downwards until it reaches the maximum height.Maximum SizeSetting a maximum size to your tray will cause it to not grow infinitely, wrapping new abnormalities downwards (if the orientation is Horizontal) or sideways (if the orientation is Vertical)." } ]
