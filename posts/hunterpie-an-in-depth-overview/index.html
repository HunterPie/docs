<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta property="og:image" content="https://cdn.hunterpie.com/Static/evolution-of-ui.png"><meta property="twitter:image" content="https://cdn.hunterpie.com/Static/evolution-of-ui.png"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="HunterPie - An in-depth overview" /><meta property="og:locale" content="en" /><meta name="description" content="Talking a little bit about HunterPie’s architecture" /><meta property="og:description" content="Talking a little bit about HunterPie’s architecture" /><link rel="canonical" href="https://docs.hunterpie.com/posts/hunterpie-an-in-depth-overview/" /><meta property="og:url" content="https://docs.hunterpie.com/posts/hunterpie-an-in-depth-overview/" /><meta property="og:site_name" content="HunterPie" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-06-03T04:18:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="HunterPie - An in-depth overview" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-10-25T02:45:22+08:00","datePublished":"2023-06-03T04:18:00+08:00","description":"Talking a little bit about HunterPie’s architecture","headline":"HunterPie - An in-depth overview","mainEntityOfPage":{"@type":"WebPage","@id":"https://docs.hunterpie.com/posts/hunterpie-an-in-depth-overview/"},"url":"https://docs.hunterpie.com/posts/hunterpie-an-in-depth-overview/"}</script><title>HunterPie - An in-depth overview | HunterPie</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="HunterPie"><meta name="application-name" content="HunterPie"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Work+Sans:ital,wght@0,100..900;1,100..900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script> <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script> <script src="/assets/js/dist/localization-table-builder.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">HunterPie</a></div><div class="site-subtitle font-italic">A modern and powerful overlay for Monster Hunter</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/blog/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3"></i> <span>BLOG</span> </a><li class="nav-item"> <a href="/documentation/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3"></i> <span>DOCUMENTATION</span> </a><li class="nav-item"> <a href="/updates/" class="nav-link"> <i class="fa-fw fas fa-rocket ml-xl-3 mr-xl-3"></i> <span>UPDATES</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3"></i> <span>CATEGORIES</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/haato3o " aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" https://discord.gg/5pdDq4Q" aria-label="discord" target="_blank" rel="noopener"> <i class="fab fa-discord"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>HunterPie - An in-depth overview</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <img data-src="https://cdn.hunterpie.com/Static/evolution-of-ui.png" class="preview-img bg" alt="Preview Image" data-proofer-ignore><h1 data-toc-skip><blog> HunterPie - An in-depth overview</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/haato3o">Haato</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1685737080" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2023-06-03 </em> </span> <span> Updated <em class="timeago" data-ts="1761331522" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2025-10-24 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3008 words"> <em>16 min</em> read</span></div></div></div><div class="post-content"><blockquote class="prompt-support"><div><p>If you enjoy HunterPie and want to support its development, consider supporting on <a href="https://www.patreon.com/HunterPie">Patreon</a>!</p></div></blockquote><p>HunterPie is an overlay for Monster Hunter games, it displays useful in-game information that are not visible to the player such as monster health, damage done, time left on your buffs and debuffs and some weapon-specific data.</p><p>In order for it to work, it needs to get those values from somewhere, in this case, from the game process’s memory itself! The thing is, messing with closed source software isn’t really straightforward, depending on how a process was compiled and which language it was made on, the human readable part code is completely removed from the binaries, you won’t have the class, structs, function and method names, it will be just a bunch of bytes, offsets and instructions. This article will be split up into 2 topics, the reverse engineering and HunterPie’s architecture.</p><h2 id="the-reverse-engineering">The Reverse Engineering <a href="#the-reverse-engineering" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Reverse engineering is an arduous and time consuming, although fun, process. A big part of it is to assume things, I’m not a game developer myself but as a software engineer you can have a pretty good idea on how things are implemented.</p><p>For instance, what is the first thing that comes in mind when you think of a health value? Probably a number, those can be usually implemented using integers or floating point decimals, in the case of Monster Hunter World, that was implemented using a <code class="language-plaintext highlighter-rouge">float</code> type.</p><p>It is important to note that in order to assume things, you also need to understand the basics of data types and data structures. For example, how would the following data structure look like in memory in a x64 game?</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Player</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">health</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">maxHealth</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>It would look like the following:</p><p><img data-src="https://cdn.hunterpie.com/Static/struct-memory.png" alt="struct hex display" data-proofer-ignore></p><p>The other important part of reverse engineering is to understand at least the basics of what happens when a program is compiled down to native machine code, what is the stack memory? The heap? If you wrote a code that access a field in a class, what would that look like in assembly? All that is important to know before diving into how HunterPie works exactly and I’ll be explaining those concepts since they’re really important.</p><h2 id="types-structures--classes">Types, Structures &amp; Classes <a href="#types-structures--classes" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Monster Hunter World is written in C++ and follows the OOP concepts, which means there are a lot of abstract classes, inheritance, etc.</p><h3 id="types">Types <a href="#types" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Memory is just a contiguous and really big array bytes, knowing all the primitive types is really helpful because that’s how you’re going to be able to map the structures by hand, for instance, the following little endian hex value <code class="language-plaintext highlighter-rouge">00 00 80 3F</code> is the <code class="language-plaintext highlighter-rouge">float32</code> value for <strong>1.0</strong>, but if you tried to read it as an <code class="language-plaintext highlighter-rouge">int</code>, it would represent <strong>1065353216</strong>. Depending on how you read the bytes or how many bytes you are reading the value can change drastically. When I look at the memory, deducing the type I’m working with is very contextual.</p><p>There are a couple of things you can look for when trying to figure out which types you’re looking at, for example, when you’re working with a float or double, those are usually stored in floating point registers (<code class="language-plaintext highlighter-rouge">xmm0</code>, <code class="language-plaintext highlighter-rouge">xmm1</code>, etc) or handled by floating point instructions like the <code class="language-plaintext highlighter-rouge">movss</code>. On the other hand, integers are <em>usually</em> stored in the QWORD registers (<code class="language-plaintext highlighter-rouge">rax</code>, <code class="language-plaintext highlighter-rouge">rbx</code>, etc).</p><h3 id="structures">Structures <a href="#structures" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>You can think of a structure as a little box of primitive types, when you’re looking at memory you won’t be able to tell how many fields there are, or where a field starts or ends, that’s when putting breakpoints on the memory addresses with a debugger come useful. It allows you to see which instructions access that given memory address, here’s a simple example:</p><div class="language-nasm highlighter-rouge"><div class="code-header"> <span data-label-text="Nasm"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nf">movss</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">movss</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebx</span><span class="p">]</span>
</pre></table></code></div></div><p>When looking at the previous two instructions, we can tell that <code class="language-plaintext highlighter-rouge">rax</code> is an structure and it has two fields, the first field is mostly likely a<code class="language-plaintext highlighter-rouge">float</code> since it’s being put in a <code class="language-plaintext highlighter-rouge">float</code> register, the second one is a pointer since it’s being dereferenced with the offset <code class="language-plaintext highlighter-rouge">4</code>, the pointer also points to another structure with a float. You could represent that as:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">RBX</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">RAX</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">RBX</span><span class="o">*</span> <span class="n">rbx</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="classes">Classes <a href="#classes" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>An easy way to think of classes in memory is to think of a struct, and the methods as functions where the first parameter is a reference to that struct. Consider the following class:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Player</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">float</span> <span class="n">GetHealth</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_health</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">char</span><span class="o">*</span> <span class="nf">GetName</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_name</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">float</span> <span class="n">m_health</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">m_maxHealth</span><span class="p">;</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">m_name</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s safe to say that if you compiled the previous class and wanted to “transpile” the assembly code to something more human readable, it would look something like this:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Player</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">health</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">maxHealth</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">float</span> <span class="nf">GetHealth</span><span class="p">(</span><span class="n">Player</span><span class="o">*</span> <span class="n">player</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">player</span><span class="o">-&gt;</span><span class="n">health</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span><span class="o">*</span> <span class="nf">GetName</span><span class="p">(</span><span class="n">Player</span><span class="o">*</span> <span class="n">player</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">player</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s good to know these type of things because when you’re reverse engineering a procedure in assembly, if the first parameter is an 8 byte long value that is often dereferenced with offsets, there’s a pretty big chance that procedure is an implementation of a method for that given pointer, and that helps a lot when trying to understand what that procedure does.</p><p>In the case of virtual functions, things change a little bit and get more complicated, a table will be created for that class and a pointer to that table will be the first field in the structure, this was very common in Monster Hunter World, as every monster had it’s own class but they all inherited a common enemy class with virtual methods. The same class <code class="language-plaintext highlighter-rouge">Player</code> could be represented like this if it implemented virtual functions:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Player</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">vptr</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">health</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">maxHealth</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Although the <em>vtable</em> is generated automatically by the compiler, the dereference and calls are done in runtime, so unlike non-virtual functions that are called by their already-known relative address, virtual functions need to be dereferenced and put into a register before being called, which makes it fairly easy to tell when you’re dealing with a virtual function.</p><div class="language-nasm highlighter-rouge"><div class="code-header"> <span data-label-text="Nasm"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">; Assuming rax is a Player*</span>
<span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span> <span class="c1">; Puts the value of vptr into the rbx register</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbx</span><span class="p">]</span> <span class="c1">; Puts the pointer to the virtual function into the rdx register</span>
<span class="nf">call</span> <span class="nb">rdx</span>       <span class="c1">; Calls the virtual function</span>
</pre></table></code></div></div><h2 id="memory">Memory <a href="#memory" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>The process’s memory can be split up in two, the static memory and the dynamic memory. The static memory is the one that is embedded in the executable itself, the compiler is the one responsible for this one, this memory is where global and static variables are, this is very important because that’s how HunterPie (and the software itself) get to the values in the dynamic memory. The memory addresses in the static memory are always the same, unless you change something internally in the code and recompile your program.</p><p>The dynamic memory on the other hand is well… Dynamic! The addresses are never the same, those are handled by the OS in runtime whenever your software needs more memory. The heap and the stack are also part of the dynamic memory, whenever you use the keyword <code class="language-plaintext highlighter-rouge">new</code> or use the <code class="language-plaintext highlighter-rouge">malloc</code> function, it will reserve some space in the memory and give you a pointer to that address, and for local variables the stack will be used for primitive types.</p><p>The thing is, you can get to anything in the dynamic memory from the static memory, you just need the right offsets to get to your desired data, and that’s the tricky part. The process of finding the offsets from the static memory to the value you want is done backwards; First you find the value you want by scanning the dynamic memory with possible values (this is where assuming things come in) and then you put a breakpoint on the accessors of that value and look at what which instructions accesses them.</p><p>Consider the following image:</p><p><img data-src="https://cdn.hunterpie.com/Static/pointer-explained.png" alt="pointers" data-proofer-ignore></p><p>Let’s say the value you found is the second field in the <strong>Structure 3</strong>, the <code class="language-plaintext highlighter-rouge">int</code> one, when you put a breakpoint on it, you might get an instruction accessing a register plus the offset <strong>4</strong>, something like this:</p><div class="language-nasm highlighter-rouge"><div class="code-header"> <span data-label-text="Nasm"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">eax</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="c1">; The instruction and registers might differ</span>
</pre></table></code></div></div><p>That means the base address of our structure is <code class="language-plaintext highlighter-rouge">0x1004 - 4 = 0x1000</code>, with that value you can now scan for all addresses that contains the value <code class="language-plaintext highlighter-rouge">0x1000</code>, that will give you a list of all possible <strong>Structure 3</strong> pointers.</p><p>You can now put a breakpoint on that pointer and see the instructions, that access it, it should be something like:</p><div class="language-nasm highlighter-rouge"><div class="code-header"> <span data-label-text="Nasm"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="o">+</span><span class="mh">14h</span><span class="p">]</span>
</pre></table></code></div></div><p>By doing the same process you did previously, you’ll find the static memory, now you can always get to the <strong>Structure 3</strong>’s desired field by following that “path” of offsets, you just need to dereference the static address with the offsets you found:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Static Memory -&gt; (Structure 1 + 0x14) -&gt; (Structure 3 + 0x4) -&gt; Desired field 
</pre></table></code></div></div><p>Dereferencing the memory values from the static memory is HunterPie’s main way to extract the data from the game, it is constantly reading the game’s memory and updating the values internally.</p><h2 id="dll-injection">DLL Injection <a href="#dll-injection" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Sometimes you want to access the process’s data that is not in memory, in Monster Hunter Rise, for example, the player’s damage is not stored in memory, so scanning the memory for them is not possible.</p><p>One of HunterPie’s core feature is to be able to track and plot the player’s damage on screen, for that to work properly I had to use another technique. Code injection and function hooks!</p><h3 id="injection">Injection <a href="#injection" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>There are a couple of ways to inject code into other processes, but the easiest is to use Window’s <code class="language-plaintext highlighter-rouge">kernel32</code>. It has some very useful functions that can be used for this purpose:</p><ol><li>Open a handle to another process (<code class="language-plaintext highlighter-rouge">OpenProcess</code>)<li>Allocate memory in another process (<code class="language-plaintext highlighter-rouge">VirtualAllocEx</code>)<li>Write to another process’s memory (<code class="language-plaintext highlighter-rouge">WriteProcessMemory</code>)<li>Load library from a path (<code class="language-plaintext highlighter-rouge">LoadLibraryW</code>)<li>Create threads in another process (<code class="language-plaintext highlighter-rouge">CreateRemoteThread</code>)</ol><p>These 5 steps allow you to inject a library, you start by opening a process handle, allocating enough memory to be able to write a path to your DLL file, writing the string, finding the remote process’s <code class="language-plaintext highlighter-rouge">LoadLibraryW</code> address and then creating a remote thread using that <code class="language-plaintext highlighter-rouge">LoadLibraryW</code> as start address and the injected string as a parameter.</p><p>That will make the remote process load the library you want.</p><h3 id="function-hooks">Function Hooks <a href="#function-hooks" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Function hooks, also known as trampoline or detouring, is a very useful technique to make a process execute code whenever a built-in function is called. If you’re interested on details on this one, take a look at <a href="https://github.com/TsudaKageyu/minhook">MinHook</a>.</p><p>Basically it replace the first couple instructions from a procedure with a <code class="language-plaintext highlighter-rouge">jmp</code> instruction pointing to a relative address to where your function is, and then another <code class="language-plaintext highlighter-rouge">jmp</code> on your detoured function to jump back to the original instructions.</p><p>This technique allows you to execute code that receives the same parameters as the original function or even change behavior of the original function.</p><h2 id="hunterpie">HunterPie <a href="#hunterpie" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now that you’ve seen the basics on how to extract values from another process, it’s easier to explain HunterPie’s architecture.</p><p>The application is split up in 4 modules: Core, UI, Integrations and HunterPie itself.</p><p><img data-src="https://cdn.hunterpie.com/Static/architecture-layers.png" alt="architecture layers" data-proofer-ignore></p><ul><li><strong>Core:</strong> Contains the application domain entities, this includes common interfaces, configuration definitions, event models, and services that can be used by other modules.<li><strong>Integrations:</strong> This is the module that handles the logic for scanning each game, it’s responsible for implementing the interfaces that are on Core.<li><strong>UI:</strong> As the name implies, it’s the module responsible for UI related things such as visual controls, data converters, views and view models. The UI module is agnostic to the game integrations which makes the overlay components fully reusable independently of the game.<li><strong>HunterPie:</strong> This is the program itself, it is responsible to initialize all the other modules and handle internal features.</ul><p>HunterPie follows an event-based architecture model, there are events for everything that have the possibility of changing. Whenever you start a supported game, a new <code class="language-plaintext highlighter-rouge">IContext</code> is instantiated, that interface contains ways to access player, enemies and also game data through the <code class="language-plaintext highlighter-rouge">IPlayer</code>, <code class="language-plaintext highlighter-rouge">IMonster</code> and <code class="language-plaintext highlighter-rouge">IGame</code> interfaces.</p><p>The previous interfaces are responsible for update values internally and also dispatch events for those values.</p><p>For example, to start receiving events of the player’s level, you can just subscribe to the <code class="language-plaintext highlighter-rouge">OnLevelChange</code> event.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="p">[...]</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">SubscribeToEvents</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">context</span><span class="p">.</span><span class="n">Game</span><span class="p">.</span><span class="n">Player</span><span class="p">.</span><span class="n">OnLevelChange</span> <span class="p">+=</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">Log</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">$"The player is now level </span><span class="p">{</span><span class="n">args</span><span class="p">.</span><span class="n">MasterRank</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">[...]</span>
</pre></table></code></div></div><p>Whenever HunterPie detect that the player’s level changed in-game, it will update the internal value in the <code class="language-plaintext highlighter-rouge">IPlayer</code> class and dispatch the event to all its subscribers.</p><h3 id="detecting-values-changes">Detecting values changes <a href="#detecting-values-changes" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>HunterPie tracks values using two different approaches, the first one is by constantly scanning the game’s memory for static addresses and offset paths to the data it needs to works. The second one is by injecting a native library inside the game and opening a communication layer between HunterPie and the game.</p><h3 id="memory-scanning">Memory scanning <a href="#memory-scanning" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Every supported game has a map file containing addresses and offsets that can be used, the map file looks something like this and is loaded in runtime whenever the game starts.</p><div class="language-py highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1"># Addresses
</span><span class="n">Address</span> <span class="n">QUEST_DATA_ADDRESS</span> <span class="mh">0x506F240</span>

<span class="c1"># Offsets
</span><span class="n">Offset</span> <span class="n">QUEST_STATE_OFFSETS</span> <span class="mh">0x54</span> <span class="c1"># This supports an array of integers too
</span></pre></table></code></div></div><p>Then in the scanner implementation you can fetch those values and read the memory with any type you want, this includes reading complex structures to reduce the amount of P/Invoke calls when reading multiple values.</p><div class="language-csharp highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">ScannableMethod</span><span class="p">]</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">GetQuestState</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">questState</span> <span class="p">=</span> <span class="p">(</span><span class="n">QuestState</span><span class="p">)</span><span class="n">Memory</span><span class="p">.</span><span class="n">Deref</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span>
        <span class="n">AddressMap</span><span class="p">.</span><span class="nf">GetAbsolute</span><span class="p">(</span><span class="s">"QUEST_DATA_ADDRESS"</span><span class="p">),</span>
        <span class="n">AddressMap</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="k">]&gt;</span><span class="p">(</span><span class="s">"QUEST_STATE_OFFSETS"</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">QuestStatus</span> <span class="p">=</span> <span class="n">questState</span><span class="p">.</span><span class="nf">ToStatus</span><span class="p">();</span>
    <span class="n">IsInQuest</span> <span class="p">=</span> <span class="n">questState</span> <span class="p">==</span> <span class="n">QuestState</span><span class="p">.</span><span class="n">InQuest</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">ScannableMethod</code> attribute on top of the method name allows that method to be automatically injected into HunterPie’s <code class="language-plaintext highlighter-rouge">ScanManager</code>, the scan manager will run all scannable methods in a background thread every couple milliseconds (this can be configured by the user). It also handles failures and has an internal “circuit-breaker” strategy to remove troublesome scannables if they fail too often.</p><p>Handling failures is a mandatory thing, sometimes process pointers are not valid anymore and HunterPie can read garbage values that could cause a crash if not handled correctly.</p><h3 id="native-interface">Native Interface <a href="#native-interface" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The second value tracking strategy is through a native interface, first HunterPie injects a statically linked library into the game. Once this library is loaded, it automatically opens a TCP socket server that starts listening for incoming connections from HunterPie.</p><p>To exchange data between the HunterPie application (made in C#) with HunterPie’s native interface that is injected into the game (made in C++), they use a binary protocol, the messages look like this:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">Core</span><span class="o">::</span><span class="n">Server</span><span class="o">::</span><span class="n">Models</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">IPCMessageVersion</span><span class="p">;</span>

    <span class="k">enum</span> <span class="n">IPCMessageType</span>
    <span class="p">{</span>
        <span class="n">INIT_IPC_MEMORY_ADDRESSES</span><span class="p">,</span>
        <span class="n">INIT_MH_HOOKS</span><span class="p">,</span>
        <span class="n">GET_HUNT_STATISTICS</span><span class="p">,</span>
        <span class="n">DELETE_HUNT_STATISTICS</span><span class="p">,</span>
        <span class="n">CLEAR_HUNT_STATISTICS</span><span class="p">,</span>
        <span class="n">UNKNOWN</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">IPCMessage</span>
    <span class="p">{</span>
        <span class="n">IPCMessageType</span> <span class="n">type</span><span class="p">;</span>
        <span class="n">IPCMessageVersion</span> <span class="n">version</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Every message will receive the <code class="language-plaintext highlighter-rouge">IPCMessage</code> structure as its first field, allowing HunterPie to call the right <code class="language-plaintext highlighter-rouge">MessageHandler</code> based on the <code class="language-plaintext highlighter-rouge">IPCMessageType</code> and <code class="language-plaintext highlighter-rouge">IPCMessageVersion</code>.</p><p><img data-src="https://cdn.hunterpie.com/Static/ipc-architecture.png" alt="ipc architecture" data-proofer-ignore></p><h3 id="the-overlay">The Overlay <a href="#the-overlay" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The overlay is one of HunterPie’s main features and is also the most used one, the architecture is very similar to <em>Model View ViewModel</em> (MVVM) pattern but instead of having a “Model”, HunterPie has what I call <code class="language-plaintext highlighter-rouge">IContextHandler</code>.</p><ul><li>The Views is responsible for the UI itself, it’s what the user will visualize;<li>The ViewModel is responsible to control the data the <em>View</em> will display through data bindings;<li>The <code class="language-plaintext highlighter-rouge">IContextHandler</code> is the one responsible to subscribe and handle HunterPie game context’s events. It has direct access to both the View and to the ViewModel it is controlling, but they cannot see the <code class="language-plaintext highlighter-rouge">IContextHandler</code>.</ul><p><img data-src="https://cdn.hunterpie.com/Static/ui-architecture.png" alt="ui-architecture" data-proofer-ignore></p><p>This architecture makes it really easy to test how the UI is behaving since we can easily create a mock the <code class="language-plaintext highlighter-rouge">IContext</code> and simulate in-game changes.</p><p>The overlay is composed by Widgets, each Widget has its own scope and responsibility, you can have the Monster Widget, that is responsible to display Monster’s information, the Damage Meter Widget that displays the damage done by the players in your party, the Abnormalities Widget that tracks and displays your buffs and debuffs timers, and so on.</p><p>Every Widget is agnostic to what game you are playing, so it doesn’t matter whether you’re playing Monster Hunter World or Monster Hunter Rise, the Widget components will be reused for both games.</p><h3 id="hunt-exports">Hunt Exports <a href="#hunt-exports" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Another cool feature, although very recent, is the ability to export hunts. Since HunterPie is constantly tracking in-game information, it is able to track vital information to build a history graph of what happened in your game session.</p><p><img data-src="https://cdn.hunterpie.com/Static/hunt-export-demo.png" alt="hunt export demo" data-proofer-ignore></p><p>It displays the party members, their damage over time and the (de)buff uptimes. This is possible because since HunterPie follows an event-based architecture, it can “recreate” what happened in-game based on the order that HunterPie’s internal events were dispatched!</p><p>At the end of every hunt, HunterPie will automatically serialize that data and upload it to HunterPie’s backend and link the upload to the user’s account.</p><h2 id="conclusions">Conclusions <a href="#conclusions" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>HunterPie has been released 4 years ago, the current architecture was very different years ago and is the result to solve solutions I had in the past due to a not well-thought-of architecture. It also took me years to learn things I know now about reverse engineering now, but one thing I can say is that the process of learning all of it was very fun, interesting and changed the way I see software engineering nowadays.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blog/'>Blog</a>, <a href='/categories/architecture/'>Architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=HunterPie - An in-depth overview - HunterPie&amp;url=https://docs.hunterpie.com/posts/hunterpie-an-in-depth-overview/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=HunterPie - An in-depth overview - HunterPie&amp;u=https://docs.hunterpie.com/posts/hunterpie-an-in-depth-overview/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://docs.hunterpie.com/posts/hunterpie-an-in-depth-overview/&amp;text=HunterPie - An in-depth overview - HunterPie" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/development-of-hunterpie/">The development of HunterPie</a><li><a href="/posts/update-v2.8.0/">HunterPie v2.8.0</a><li><a href="/posts/hunterpie-an-in-depth-overview/">HunterPie - An in-depth overview</a><li><a href="/posts/update-v2.9.0/">HunterPie v2.9.0</a><li><a href="/posts/update-v2.10.0/">HunterPie v2.10.0</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/development-of-hunterpie/"><div class="card-body"> <em class="timeago small" data-ts="1679982180" > 2023-03-28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The development of HunterPie</h3><div class="text-muted small"><p> If you enjoy HunterPie and want to support its development, consider supporting on Patreon! Some context I have been actively developing and maintaining HunterPie and all its dependencies for...</p></div></div></a></div><div class="card"> <a href="/posts/activities-widget/"><div class="card-body"> <em class="timeago small" data-ts="1761258060" > 2025-10-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Activities Widget</h3><div class="text-muted small"><p> The Activities Widget is responsible for tracking and displaying data from activities from the game. Games Monster Hunter Wilds The following activities are supported: Material Retrieval; ...</p></div></div></a></div><div class="card"> <a href="/posts/update-v2.13.0/"><div class="card-body"> <em class="timeago small" data-ts="1761065460" > 2025-10-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>HunterPie v2.13.0</h3><div class="text-muted small"><p> If you enjoy HunterPie and want to support its development, consider supporting on Patreon! Theme System Overhaul Starting with v2.13, HunterPie will have a new theming system. This new syste...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/update-v2.8.0/" class="btn btn-outline-primary" prompt="Older"><p>HunterPie v2.8.0</p></a> <a href="/posts/update-v2.9.0/" class="btn btn-outline-primary" prompt="Newer"><p>HunterPie v2.9.0</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/haato3o">Haato</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-N71GHF7F3Q"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-N71GHF7F3Q'); }); </script>
